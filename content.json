{"meta":{"title":"老夫正年轻","subtitle":"醒握杀人剑，醉卧美人膝","description":"醒握杀人剑，醉卧美人膝","author":"老夫正年轻","url":"http://blog.12xiaoshi.com"},"pages":[],"posts":[{"title":"一段Java获取免费代理服务器的代码","slug":"tech/free_proxy_list_by_java","date":"2017-08-17T09:06:18.750Z","updated":"2015-04-07T17:17:55.589Z","comments":true,"path":"2017/08/17/tech/free_proxy_list_by_java/","link":"","permalink":"http://blog.12xiaoshi.com/2017/08/17/tech/free_proxy_list_by_java/","excerpt":"数据来源： http://www.proxylists.net/ 类似数据，还可以参考： http://www.proxz.com/，对应RSS地址：http://www.proxz.com/proxylists.xmlhttp://www.xroxy.com/，对应RSS地址：http://www.xroxy.com/proxyrss.xml 核心依赖包（RSS的解析）： &lt;dependency&gt; &lt;groupId&gt;rome&lt;/groupId&gt; &lt;artifactId&gt;rome-fetcher&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt;","text":"数据来源： http://www.proxylists.net/ 类似数据，还可以参考： http://www.proxz.com/，对应RSS地址：http://www.proxz.com/proxylists.xmlhttp://www.xroxy.com/，对应RSS地址：http://www.xroxy.com/proxyrss.xml 核心依赖包（RSS的解析）： &lt;dependency&gt; &lt;groupId&gt;rome&lt;/groupId&gt; &lt;artifactId&gt;rome-fetcher&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; 不废话，上代码： package com.mapprouter.thirdparty.httpclient; import java.net.URL; import java.util.List; import java.util.Set; import org.jdom.Element; import com.google.common.collect.Sets; import com.sun.syndication.feed.synd.SyndEntry; import com.sun.syndication.feed.synd.SyndFeed; import com.sun.syndication.io.SyndFeedInput; import com.sun.syndication.io.XmlReader; /** * @author kalman03 * @since 2015年4月7日 */ public class ProxyLists { // // public static void main(String[] args) { // Set&lt;ProxyDO&gt; ss = getProxyList(); // for (ProxyDO do1 : ss) { // System.out.println(do1); // } // } @SuppressWarnings(&quot;unchecked&quot;) public static Set&lt;ProxyDO&gt; getProxyList() { Set&lt;ProxyDO&gt; sets = Sets.newHashSet(); try { URL url = new URL(&quot;http://www.proxylists.net/proxylists.xml&quot;); XmlReader reader = new XmlReader(url); SyndFeedInput input = new SyndFeedInput(); SyndFeed feed = input.build(reader); List&lt;SyndEntry&gt; entries = feed.getEntries(); for (SyndEntry entry : entries) { List&lt;Element&gt; items = (List&lt;Element&gt;) entry.getForeignMarkup(); for (Element element : items) { List&lt;Element&gt; proxies = element.getChildren(); ProxyDO proxyDO = new ProxyDO(); for (Element proxy : proxies) { if(proxy.getName().equals(&quot;ip&quot;)){ proxyDO.setIp(proxy.getText()); }else if(proxy.getName().equals(&quot;port&quot;)){ proxyDO.setPort(Integer.parseInt(proxy.getText())); }else if(proxy.getName().equals(&quot;type&quot;)){ proxyDO.setType(proxy.getText()); }else if(proxy.getName().equals(&quot;country&quot;)){ proxyDO.setCountry(proxy.getText()); }else if(proxy.getName().equals(&quot;check_timestamp&quot;)){ proxyDO.setChecked(proxy.getText()); } } sets.add(proxyDO); } } } catch (Exception e) { e.printStackTrace(); } return sets; } } 以上代码针对不同proxy的RSS源，通用。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"代理服务器","slug":"代理服务器","permalink":"http://blog.12xiaoshi.com/tags/代理服务器/"},{"name":"proxy","slug":"proxy","permalink":"http://blog.12xiaoshi.com/tags/proxy/"}]},{"title":"针对婴儿感冒发烧的常备处方","slug":"life/baby_fever","date":"2017-08-17T09:06:18.487Z","updated":"2015-04-08T03:02:43.245Z","comments":true,"path":"2017/08/17/life/baby_fever/","link":"","permalink":"http://blog.12xiaoshi.com/2017/08/17/life/baby_fever/","excerpt":"小孩子常感冒发烧拉肚子，整理几个在浙江省儿保开的药，都是分（ju）量(du)很(wu)重(bi)的药，所以做个备忘。","text":"小孩子常感冒发烧拉肚子，整理几个在浙江省儿保开的药，都是分（ju）量(du)很(wu)重(bi)的药，所以做个备忘。 （美林/Motrin）艾畅 一般用于感冒引起的鼻塞、流涕、咳嗽。 我搞不懂这两个包装有什么区别，看药物成分都是一样的。 网上有人说这款药有很大的副作用，各位自己看着办，是药三分毒，谨遵医嘱。 泰诺 和 美林 主要是解决高烧，一般在38.5度以上才会用，两种不要同时用（假如一种无效，可尝试切换另外一种），一般用药5-15分钟高烧会减退到38.5以下。这两种药要少用，只有在体温到38.5-39度以上（持续高烧严重会烧坏脑神经，造成脑膜炎等严重后果）才去用，因为副作用很大。 #希克劳 # 小孩发热乏力时候开的，袋状需要开水冲服。 头孢克肟颗粒 感冒等引起的炎症","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.12xiaoshi.com/tags/生活/"},{"name":"婴儿感冒发烧","slug":"婴儿感冒发烧","permalink":"http://blog.12xiaoshi.com/tags/婴儿感冒发烧/"}]},{"title":"tcpdump","slug":"tech/tcpdump","date":"2017-07-12T15:49:01.000Z","updated":"2017-08-17T09:38:14.531Z","comments":true,"path":"2017/07/12/tech/tcpdump/","link":"","permalink":"http://blog.12xiaoshi.com/2017/07/12/tech/tcpdump/","excerpt":"tcpdump -vv -i eth1 host 183.57.53.145 or 183.57.53.144 -s 65535 -w ./aaa.cap .cap适合Wireshark分析 .pcap适合Charles分析","text":"tcpdump -vv -i eth1 host 183.57.53.145 or 183.57.53.144 -s 65535 -w ./aaa.cap .cap适合Wireshark分析 .pcap适合Charles分析 -A 以ASCII码方式显示每一个数据包(不会显示数据包中链路层头部信息). 在抓取包含网页数据的数据包时, 可方便查看数据(nt: 即Handy for capturing web pages). -c count tcpdump将在接受到count个数据包后退出. -C file-size (nt: 此选项用于配合-w file 选项使用) 该选项使得tcpdump 在把原始数据包直接保存到文件中之前, 检查此文件大小是否超过file-size. 如果超过了, 将关闭此文件,另创一个文件继续用于原始数据包的记录. 新创建的文件名与-w 选项指定的文件名一致, 但文件名后多了一个数字.该数字会从1开始随着新创建文件的增多而增加. file-size的单位是百万字节(nt: 这里指1,000,000个字节,并非1,048,576个字节, 后者是以1024字节为1k, 1024k字节为1M计算所得, 即1M=1024 ＊ 1024 ＝ 1,048,576) -d 以容易阅读的形式,在标准输出上打印出编排过的包匹配码, 随后tcpdump停止.(nt | rt: human readable, 容易阅读的,通常是指以ascii码来打印一些信息. compiled, 编排过的. packet-matching code, 包匹配码,含义未知, 需补充) -dd 以C语言的形式打印出包匹配码. -ddd 以十进制数的形式打印出包匹配码(会在包匹配码之前有一个附加的’count’前缀). -D 打印系统中所有tcpdump可以在其上进行抓包的网络接口. 每一个接口会打印出数字编号, 相应的接口名字, 以及可能的一个网络接口描述. 其中网络接口名字和数字编号可以用在tcpdump 的-i flag 选项(nt: 把名字或数字代替flag), 来指定要在其上抓包的网络接口. 此选项在不支持接口列表命令的系统上很有用(nt: 比如, Windows 系统, 或缺乏 ifconfig -a 的UNIX系统); 接口的数字编号在windows 2000 或其后的系统中很有用, 因为这些系统上的接口名字比较复杂, 而不易使用. 如果tcpdump编译时所依赖的libpcap库太老,-D 选项不会被支持, 因为其中缺乏 pcap_findalldevs()函数. -e 每行的打印输出中将包括数据包的数据链路层头部信息 -E spi@ipaddr algo:secret,… 可通过spi@ipaddr algo:secret 来解密IPsec ESP包(nt | rt:IPsec Encapsulating Security Payload,IPsec 封装安全负载, IPsec可理解为, 一整套对ip数据包的加密协议, ESP 为整个IP 数据包或其中上层协议部分被加密后的数据,前者的工作模式称为隧道模式; 后者的工作模式称为传输模式 . 工作原理, 另需补充). 需要注意的是, 在终端启动tcpdump 时, 可以为IPv4 ESP packets 设置密钥(secret）. 可用于加密的算法包括des-cbc, 3des-cbc, blowfish-cbc, rc3-cbc, cast128-cbc, 或者没有(none).默认的是des-cbc(nt: des, Data Encryption Standard, 数据加密标准, 加密算法未知, 另需补充).secret 为用于ESP 的密钥, 使用ASCII 字符串方式表达. 如果以 0x 开头, 该密钥将以16进制方式读入. 该选项中ESP 的定义遵循RFC2406, 而不是 RFC1827. 并且, 此选项只是用来调试的, 不推荐以真实密钥(secret)来使用该选项, 因为这样不安全: 在命令行中输入的secret 可以被其他人通过ps 等命令查看到. 除了以上的语法格式(nt: 指spi@ipaddr algo:secret), 还可以在后面添加一个语法输入文件名字供tcpdump 使用(nt：即把spi@ipaddr algo:secret,... 中...换成一个语法文件名). 此文件在接受到第一个ESP 包时会打开此文件, 所以最好此时把赋予tcpdump 的一些特权取消(nt: 可理解为, 这样防范之后, 当该文件为恶意编写时,不至于造成过大损害). -f 显示外部的IPv4 地址时(nt: foreign IPv4 addresses, 可理解为, 非本机ip地址), 采用数字方式而不是名字.(此选项是用来对付Sun公司的NIS服务器的缺陷(nt: NIS, 网络信息服务, tcpdump 显示外部地址的名字时会用到她提供的名称服务): 此NIS服务器在查询非本地地址名字时,常常会陷入无尽的查询循环). 由于对外部(foreign)IPv4地址的测试需要用到本地网络接口(nt: tcpdump 抓包时用到的接口)及其IPv4 地址和网络掩码. 如果此地址或网络掩码不可用, 或者此接口根本就没有设置相应网络地址和网络掩码(nt: linux 下的 &apos;any&apos; 网络接口就不需要设置地址和掩码, 不过此&apos;any&apos;接口可以收到系统中所有接口的数据包), 该选项不能正常工作. -F file 使用file 文件作为过滤条件表达式的输入, 此时命令行上的输入将被忽略. -i interface 指定tcpdump 需要监听的接口. 如果没有指定, tcpdump 会从系统接口列表中搜寻编号最小的已配置好的接口(不包括 loopback 接口).一但找到第一个符合条件的接口, 搜寻马上结束. 在采用2.2版本或之后版本内核的Linux 操作系统上, &apos;any&apos; 这个虚拟网络接口可被用来接收所有网络接口上的数据包(nt: 这会包括目的是该网络接口的, 也包括目的不是该网络接口的). 需要注意的是如果真实网络接口不能工作在&apos;混杂&apos;模式(promiscuous)下,则无法在&apos;any&apos;这个虚拟的网络接口上抓取其数据包. 如果 -D 标志被指定, tcpdump会打印系统中的接口编号，而该编号就可用于此处的interface 参数. -l 对标准输出进行行缓冲(nt: 使标准输出设备遇到一个换行符就马上把这行的内容打印出来).在需要同时观察抓包打印以及保存抓包记录的时候很有用. 比如, 可通过以下命令组合来达到此目的: tcpdump -l | tee dat&#39;&#39; 或者tcpdump -l &gt; dat &amp; tail -f dat’’.(nt: 前者使用tee来把tcpdump 的输出同时放到文件dat和标准输出中, 而后者通过重定向操作’&gt;’, 把tcpdump的输出放到dat 文件中, 同时通过tail把dat文件中的内容放到标准输出中) -L 列出指定网络接口所支持的数据链路层的类型后退出.(nt: 指定接口通过-i 来指定) -m module 通过module 指定的file 装载SMI MIB 模块(nt: SMI，Structure of Management Information, 管理信息结构MIB, Management Information Base, 管理信息库. 可理解为, 这两者用于SNMP(Simple Network Management Protoco)协议数据包的抓取. 具体SNMP 的工作原理未知, 另需补充). 此选项可多次使用, 从而为tcpdump 装载不同的MIB 模块. -M secret 如果TCP 数据包(TCP segments)有TCP-MD5选项(在RFC 2385有相关描述), 则为其摘要的验证指定一个公共的密钥secret. -n 不对地址(比如, 主机地址, 端口号)进行数字表示到名字表示的转换. -N 不打印出host 的域名部分. 比如, 如果设置了此选现, tcpdump 将会打印’nic’ 而不是 ‘nic.ddn.mil’. -O 不启用进行包匹配时所用的优化代码. 当怀疑某些bug是由优化代码引起的, 此选项将很有用. -p 一般情况下, 把网络接口设置为非’混杂’模式. 但必须注意 , 在特殊情况下此网络接口还是会以’混杂’模式来工作； 从而, ‘-p’ 的设与不设, 不能当做以下选现的代名词:’ether host {local-hw-add}’ 或 ‘ether broadcast’(nt: 前者表示只匹配以太网地址为host 的包, 后者表示匹配以太网地址为广播地址的数据包). -q 快速(也许用’安静’更好?)打印输出. 即打印很少的协议相关信息, 从而输出行都比较简短. -R 设定tcpdump 对 ESP/AH 数据包的解析按照 RFC1825而不是RFC1829(nt: AH, 认证头, ESP， 安全负载封装, 这两者会用在IP包的安全传输机制中). 如果此选项被设置, tcpdump 将不会打印出’禁止中继’域(nt: relay prevention field). 另外,由于ESP/AH规范中没有规定ESP/AH数据包必须拥有协议版本号域,所以tcpdump不能从收到的ESP/AH数据包中推导出协议版本号. -r file 从文件file 中读取包数据. 如果file 字段为 ‘-‘ 符号, 则tcpdump 会从标准输入中读取包数据. -S 打印TCP 数据包的顺序号时, 使用绝对的顺序号, 而不是相对的顺序号.(nt: 相对顺序号可理解为, 相对第一个TCP 包顺序号的差距,比如, 接受方收到第一个数据包的绝对顺序号为232323, 对于后来接收到的第2个,第3个数据包, tcpdump会打印其序列号为1, 2分别表示与第一个数据包的差距为1 和 2. 而如果此时-S 选项被设置, 对于后来接收到的第2个, 第3个数据包会打印出其绝对顺序号:232324, 232325). -s snaplen 设置tcpdump的数据包抓取长度为snaplen, 如果不设置默认将会是68字节(而支持网络接口分接头(nt: NIT, 上文已有描述,可搜索’网络接口分接头’关键字找到那里)的SunOS系列操作系统中默认的也是最小值是96).68字节对于IP, ICMP(nt: Internet Control Message Protocol,因特网控制报文协议), TCP 以及 UDP 协议的报文已足够, 但对于名称服务(nt: 可理解为dns, nis等服务), NFS服务相关的数据包会产生包截短. 如果产生包截短这种情况, tcpdump的相应打印输出行中会出现’’[|proto]’’的标志（proto 实际会显示为被截短的数据包的相关协议层次). 需要注意的是, 采用长的抓取长度(nt: snaplen比较大), 会增加包的处理时间, 并且会减少tcpdump 可缓存的数据包的数量， 从而会导致数据包的丢失. 所以, 在能抓取我们想要的包的前提下, 抓取长度越小越好.把snaplen 设置为0 意味着让tcpdump自动选择合适的长度来抓取数据包. -T type 强制tcpdump按type指定的协议所描述的包结构来分析收到的数据包. 目前已知的type 可取的协议为: aodv (Ad-hoc On-demand Distance Vector protocol, 按需距离向量路由协议, 在Ad hoc(点对点模式)网络中使用), cnfp (Cisco NetFlow protocol), rpc(Remote Procedure Call), rtp (Real-Time Applications protocol), rtcp (Real-Time Applications con-trol protocol), snmp (Simple Network Management Protocol), tftp (Trivial File Transfer Protocol, 碎文件协议), vat (Visual Audio Tool, 可用于在internet 上进行电 视电话会议的应用层协议), 以及wb (distributed White Board, 可用于网络会议的应用层协议). -t 在每行输出中不打印时间戳 -tt 不对每行输出的时间进行格式处理(nt: 这种格式一眼可能看不出其含义, 如时间戳打印成1261798315) -ttt tcpdump 输出时, 每两行打印之间会延迟一个段时间(以毫秒为单位) -tttt 在每行打印的时间戳之前添加日期的打印 -u 打印出未加密的NFS 句柄(nt: handle可理解为NFS 中使用的文件句柄, 这将包括文件夹和文件夹中的文件) -U 使得当tcpdump在使用-w 选项时, 其文件写入与包的保存同步.(nt: 即, 当每个数据包被保存时, 它将及时被写入文件中,而不是等文件的输出缓冲已满时才真正写入此文件) -U 标志在老版本的libcap库(nt: tcpdump 所依赖的报文捕获库)上不起作用, 因为其中缺乏pcap_cump_flush()函数. -v 当分析和打印的时候, 产生详细的输出. 比如, 包的生存时间, 标识, 总长度以及IP包的一些选项. 这也会打开一些附加的包完整性检测, 比如对IP或ICMP包头部的校验和. -vv 产生比-v更详细的输出. 比如, NFS回应包中的附加域将会被打印, SMB数据包也会被完全解码. -vvv 产生比-vv更详细的输出. 比如, telent 时所使用的SB, SE 选项将会被打印, 如果telnet同时使用的是图形界面, 其相应的图形选项将会以16进制的方式打印出来(nt: telnet 的SB,SE选项含义未知, 另需补充). -w 把包数据直接写入文件而不进行分析和打印输出. 这些包数据可在随后通过-r 选项来重新读入并进行分析和打印. -W filecount 此选项与-C 选项配合使用, 这将限制可打开的文件数目, 并且当文件数据超过这里设置的限制时, 依次循环替代之前的文件, 这相当于一个拥有filecount 个文件的文件缓冲池. 同时, 该选项会使得每个文件名的开头会出现足够多并用来占位的0, 这可以方便这些文件被正确的排序. -x 当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据(但不包括连接层的头部).总共打印的数据大小不会超过整个数据包的大小与snaplen 中的最小值. 必须要注意的是, 如果高层协议数据没有snaplen 这么长,并且数据链路层(比如, Ethernet层)有填充数据, 则这些填充数据也会被打印.(nt: so for link layers that pad, 未能衔接理解和翻译, 需补充 ) -xx tcpdump 会打印每个包的头部数据, 同时会以16进制打印出每个包的数据, 其中包括数据链路层的头部. -X 当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据(但不包括连接层的头部).这对于分析一些新协议的数据包很方便. -XX 当分析和打印时, tcpdump 会打印每个包的头部数据, 同时会以16进制和ASCII码形式打印出每个包的数据, 其中包括数据链路层的头部.这对于分析一些新协议的数据包很方便. -y datalinktype 设置tcpdump 只捕获数据链路层协议类型是datalinktype的数据包 -Z user 使tcpdump 放弃自己的超级权限(如果以root用户启动tcpdump, tcpdump将会有超级用户权限), 并把当前tcpdump的用户ID设置为user, 组ID设置为user首要所属组的ID(nt: tcpdump 此处可理解为tcpdump 运行之后对应的进程) 此选项也可在编译的时候被设置为默认打开.(nt: 此时user 的取值未知, 需补充)","categories":[],"tags":[{"name":"tcpdump","slug":"tcpdump","permalink":"http://blog.12xiaoshi.com/tags/tcpdump/"}]},{"title":"如何评估产品机会","slug":"tech/product_opt","date":"2016-09-03T15:51:01.000Z","updated":"2016-09-03T15:52:15.853Z","comments":true,"path":"2016/09/03/tech/product_opt/","link":"","permalink":"http://blog.12xiaoshi.com/2016/09/03/tech/product_opt/","excerpt":"","text":"1、产品需要解决什么问题？（产品价值） 2、为谁解决这个问题？（目标市场） 3、成功的机会有多大？（市场规模） 4、怎样判断产品成功与否？（度量指标或收益指标） 5、有哪些同类产品？（竞争格局） 6、为什么我们最适合做这个产品？（竞争优势） 7、时机合适吗？（市场时机） 8、如何把产品推向市场？（有效组合策略） 9、成功的必要条件是什么？（解决方案要满足的条件） 10、根据以上问题，给出评估结论。（继续或放弃）","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"产品经理","slug":"产品经理","permalink":"http://blog.12xiaoshi.com/tags/产品经理/"}]},{"title":"SSH连CentOS卡很久才连上","slug":"tech/ssh_slow","date":"2016-08-18T10:35:01.000Z","updated":"2016-08-18T10:57:07.980Z","comments":true,"path":"2016/08/18/tech/ssh_slow/","link":"","permalink":"http://blog.12xiaoshi.com/2016/08/18/tech/ssh_slow/","excerpt":"","text":"###解决办法： sudo vi /etc/ssh/sshd_config 找到GSSAPIAuthentication yes，修改为 GSSAPIAuthentication no UseDNS修改为no，CentOS默认是yes，即使这行已被注释，你也需要加上 UseDNS no","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"ssh","slug":"ssh","permalink":"http://blog.12xiaoshi.com/tags/ssh/"},{"name":"centos","slug":"centos","permalink":"http://blog.12xiaoshi.com/tags/centos/"}]},{"title":"客户端API请求规范","slug":"tech/api-constraint_design","date":"2016-03-31T01:35:01.000Z","updated":"2016-03-31T02:36:00.951Z","comments":true,"path":"2016/03/31/tech/api-constraint_design/","link":"","permalink":"http://blog.12xiaoshi.com/2016/03/31/tech/api-constraint_design/","excerpt":"这是一份老夫制定的客户端API请求规范，现在分享出来，希望对各位有帮助。 API请求规范，兼在明确iOS/Android等native客户端请求服务端接口的协议、参数和响应结果，所有的APP必须按照这个规范与服务端进行交互。 1、请求协议所有与服务端交互的API，都走HTTP(S)协议。 2、请求参数API的请求参数分两部分，一部分为协议参数，属于协议本身，与业务关务，如t,imei,appkey等；一部分为业务参数，这些参数会对系统中的系统流程、操作方式产生重要的影响。","text":"这是一份老夫制定的客户端API请求规范，现在分享出来，希望对各位有帮助。 API请求规范，兼在明确iOS/Android等native客户端请求服务端接口的协议、参数和响应结果，所有的APP必须按照这个规范与服务端进行交互。 1、请求协议所有与服务端交互的API，都走HTTP(S)协议。 2、请求参数API的请求参数分两部分，一部分为协议参数，属于协议本身，与业务关务，如t,imei,appkey等；一部分为业务参数，这些参数会对系统中的系统流程、操作方式产生重要的影响。 协议参数 服务端约定，客户端需在每次请求的URL里面，加上下列协议参数： 参数名 是否必须 说明 imei 必须 INTERNATIONAL_MOBILE_EQUIPMENT_IDENTITY,客户端设备标识，国际移动设备身份码 imsi 必须 INTERNATIONAL_MOBILE_SUBSCRIBER_IDENTITIFICATION_NUMBER,客户端用户标识 t 必须 TIMESTAMP,请求的时间戳，UTC 1970-1-1 0时到现在的时间差，精确到秒 appkey 必须 由服务端颁发的appkey sign 必须 md5签名串 lng 可选 LONGITUDE,手机上获取的经度 lat 可选 LATITUDE,手机上获取的纬度 ci 可选 CHANNEL_IDENTITY,渠道标识，格式为：channelId@应用名平台客户端版本，例如：1001@nzaom_android_1.0，其中1001表示应用宝 业务参数 业务具体参数由服务端在接口文档中进行约定。 2.1、参数传递协议参数必须通过url parameter传递，业务参数通过body，path，url parameter等多样化的形式传递。 服务端提供标准的Restful API，支持POST\\DELETE\\PUT\\PATCH\\GET方式。 下面两个示例分别演示GET和POST的请求: GET GET http://localhost:80/api/testGet?appkey=123456&amp;data=%7B%22name%22%3A%22%E5%A4%A7%E7%99%BD%22%2C%22sex%22%3A%22%E7%94%B7%22%7D&amp;ci=1001_nzaom_android_1.0&amp;imei=imei11111&amp;imsi=imsi22222&amp;lat=23.1&amp;lng=111.21&amp;t=1432747514991&amp;sign=760b2c16ddd8b47288b0e16871fbd5de HTTP/1.1 Host: localhost:80 Connection: Keep-Alive User-Agent: Apache-HttpClient/4.4.1 (Java/1.7.0_51) Accept-Encoding: gzip,deflate HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Expires: Thu, 01 Jan 1970 00:00:00 GMT Set-Cookie: SESSION=7a449d11-9a09-45b4-9c49-f43f0131ee51;Path=/ Content-Length: 49 Server: Jetty(6.1.22) {&quot;data&quot;: {&quot;name&quot;:&quot;大白&quot;,&quot;sex&quot;:&quot;男&quot;},message:&quot;OK&quot;,&quot;status&quot;: 200} POST POST http://localhost:80/api/testPost?appkey=123456&amp;data=%7B%22name%22%3A%22%E5%A4%A7%E7%99%BD%22%2C%22sex%22%3A%22%E7%94%B7%22%7D&amp;hci=1001_hehuyou_android_1.0&amp;imei=imei11111&amp;imsi=imsi22222&amp;lat=23.1&amp;lng=111.21&amp;t=1432747714602&amp;sign=2dfb020566c7d826e3ed7276c7c49fb8 HTTP/1.1 Content-Type: application/json;charset=UTF-8 Content-Length: 29 Host: localhost:80 Connection: Keep-Alive User-Agent: Apache-HttpClient/4.4.1 (Java/1.7.0_51) Accept-Encoding: gzip,deflate {&quot;name&quot;:&quot;大白&quot;,&quot;sex&quot;:&quot;男&quot;} HTTP/1.1 200 OK Content-Type: application/json;charset=UTF-8 Expires: Thu, 01 Jan 1970 00:00:00 GMT Set-Cookie: SESSION=13e853c2-2f55-43c6-b4f0-cb016590141a;Path=/ Content-Length: 49 Server: Jetty(6.1.22) {&quot;message&quot;: &quot;权限不够&quot;,&quot;status&quot;: 403} 2.2 参数Sign为了减轻非法恶意请求，每次来自APP的请求都需要对请求参数进行签名以实现安全认证。通过参数sign来验证参数传递是否合法，具体流程如下： 根据参数名称（除签名sign）将所有请求参数按照字母先后顺序排序:key + value …. key + value，例如：将foo=1,bar=2,baz=3 排序为bar=2,baz=3,foo=1，参数名和参数值链接后，得到拼装字符串bar2baz3foo1 将secret拼接到参数字符串尾进行md5加密后，再转化成大写，格式是：byte2hex(md5(secretkey1value1key2value2…secret)) 第2步生成的字符串即为参数sign 参考代码（Java版本）： TreeMap&lt;String, String&gt; tree=new TreeMap&lt;String, String&gt;(); Enumeration&lt;String&gt; enums = request.getParameterNames(); String param=&quot;&quot;; while(enums.hasMoreElements()){ String ele = enums.nextElement(); tree.put(ele, request.getParameter(ele)); } Iterator&lt;String&gt; it = tree.keySet().iterator(); while( it.hasNext() ){ String v=it.next(); //System.out.println(&quot; &quot;+v+&quot; decode:&quot;+java.net.URLDecoder.decode(request.getParameter(v),&quot;utf-8&quot;)); if(!&quot;sign&quot;.equals(v)){ param+=v+java.net.URLDecoder.decode(request.getParameter(v),&quot;utf-8&quot;); } } param = param+SECRET; String sign2=Md5.sign(param).toUpperCase(); System.out.println(&quot;sign:&quot;+sign); System.out.println(&quot;sign2:&quot;+sign2); if(!sign2.equalsIgnoreCase(sign)){ System.out.println(&quot;非法访问&quot;); } 注意事项： 所有的参数皆为utf-8格式 2.3 关于登录服务端和客户端都是采用基于Header的用户会话状态解决方案。登录后需要将服务端返回的token设置在Header的参数X-Auth-Token中。 2.3 关于Header目前必须传递的两个Header参数分别是： X-Auth-Token X-Platform 其中X-Auth-Token为会话token，X-Platform为请求的终端系统，如iOS、Android。如果涉及到API版本，请将版本的参数设置在Header中，Header的key为：X-Api-Version 3、响应结果服务端都以json格式返回，分成功、失败两种状态。 成功： {&quot;data&quot;: {&quot;name&quot;:&quot;大白&quot;,&quot;sex&quot;:&quot;男&quot;},message:&quot;OK&quot;,&quot;status&quot;: 200} {&quot;data&quot;: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;],message:&quot;OK&quot;,&quot;status&quot;: 200} 失败： {&quot;message&quot;: &quot;权限不够&quot;,&quot;status&quot;: 403} 4、关于错误码 400：非法请求 401：未登陆 403：权限不够 500：系统错误 900：业务级别的错误 200：正常请求","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"API设计","slug":"API设计","permalink":"http://blog.12xiaoshi.com/tags/API设计/"},{"name":"Restfull","slug":"Restfull","permalink":"http://blog.12xiaoshi.com/tags/Restfull/"},{"name":"服务端与客户端交互","slug":"服务端与客户端交互","permalink":"http://blog.12xiaoshi.com/tags/服务端与客户端交互/"}]},{"title":"一种适合创业公司的技术架构方案","slug":"tech/normal_design_base_aliyun","date":"2016-03-30T03:35:01.000Z","updated":"2016-03-30T08:42:04.529Z","comments":true,"path":"2016/03/30/tech/normal_design_base_aliyun/","link":"","permalink":"http://blog.12xiaoshi.com/2016/03/30/tech/normal_design_base_aliyun/","excerpt":"创业公司，觉得很重要的一点，是快速的以市场行动去验证业务方向的可行性。对于在创业公司的技术团队，一支作为服务支撑的团队，应该遵循的设计原则是： 业务驱动 横向扩展 互联网通用技术 在此前提下，老夫基于阿里云服务实践（是实践不是YY）了一套技术架构方案，如果你不幸步行于此，希望下图没有坑害到你。","text":"创业公司，觉得很重要的一点，是快速的以市场行动去验证业务方向的可行性。对于在创业公司的技术团队，一支作为服务支撑的团队，应该遵循的设计原则是： 业务驱动 横向扩展 互联网通用技术 在此前提下，老夫基于阿里云服务实践（是实践不是YY）了一套技术架构方案，如果你不幸步行于此，希望下图没有坑害到你。 与其说是架构方案，还不如说是脚手架，因为你所看到的，都是我们最常用的框架和技术，可能不同的是，用了一些阿里云的一些服务。 对于上图，老夫解答一些可能会存在疑问的点。 ####问题1：用了阿里云负载均衡（SLB），nginx做什么用？ SLB的主要作用的是负载均衡，同样nginx也可以做。如果只是单纯考虑负载均衡，阿里云的SLB优越性更高。 但nginx可以做的更多，如反向代理、HTTP服务器，灵活性更高。所以如果要精简，阿里云的SLB确实可以拿掉。 在实践的过程中，老夫同时用了nginx和SLB，除了反向代理，nginx还承担了一个静态站点的HTTP服务。 ####问题2：nginx可以换成apache吗？ 别废话，白菜萝卜各有所爱，关于nginx和apache的对比自己google去。 ####问题3：图中，一台阿里云ECS只部署一个Tomcat服务么？ 没错。这里没有统一的解决方案，你可以选择在一台服务器上开多个Tomcat端口，而对我来说一台服务器一个Tomcat配置更精简，再说这台ECS挂了也不至于一个集群挂了，有钱任性！ ####问题4：Spring Session的应用效果如何？ 互联网技术架构很难不涉及到分布式，关于session共享的技术方案是必须要考虑的，它需要一套完整的session框架来做这件事。Spring Session提供了一套分布式Session的解决方案，默认采用的是redis来管理session（目前最新的版本已经支持DB、redis、mongodb、gemfire等方式存储管理session）。 老夫实战过程中，Spring Session的Cookie和Header方案搭配使用，session存储阿里云redis，目前没有遇到任何障碍。 ####问题5：Swagger是什么鬼？ 如果你涉及到APP的开发，一定涉及API管理与文档的书写，Swagger是一个方便管理项目中API接口的框架。如果服务端开发同学，想更好的管理API文档，不妨尝试下Swagger，你一定会爱上它的。哦，对了，忘记告诉你，老夫其实用的是Springfox-一个基于SwaggerUI的库。 ####问题6：如何评估阿里云redis、OSS、MQ？ 在分布式session的解决方案中，session的最优存储位置是redis，如果前期用户量少，甚至可以存储在数据库中，不建议维护在memcached中。初创型公司，不建议自己维护一套redis的集群环境，成本略高。所以，如果能使用阿里云的服务，就使用之。 关于阿里云的对象存储OSS，它应该出自淘系内部的TFS，搭配阿里云CDN使用效果是毋庸置疑的。而我们基本上用到最多的就是图片、css、js的存储，这块业界有很多免费也较稳定的存储，初创企业老夫更倾向于七牛云存储。相比OSS，免费额度高，文档较完善，基本上需要的支持都有，比如图片压缩、水印、语音视频分片等。 MQ，消息队列服务。老夫其实没用，因为我用Reactor取代了，至少对于我目前的业务是可以满足的，不过分布式消息队列的重要性毋庸置疑，初创企业自己运维不及直接使用有优势。 ###业务量上来后，怎么玩？先呵呵一下，再放一图，各位看官欢迎楼下PK 老夫深深的吸一口烟，缓缓吐出一团云圈，心中嘀咕一下:支撑的业务可以赶上淘宝了…… 友情告知：以上使用阿里云的服务，可以在公司的不同阶段，自行替换为开源实现or自行实现和运维。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"阿里云","slug":"阿里云","permalink":"http://blog.12xiaoshi.com/tags/阿里云/"},{"name":"架构设计","slug":"架构设计","permalink":"http://blog.12xiaoshi.com/tags/架构设计/"},{"name":"创业公司","slug":"创业公司","permalink":"http://blog.12xiaoshi.com/tags/创业公司/"}]},{"title":"10个很棒的jQuery和HTML所见即所得编辑器插件","slug":"tech/markdown_editor","date":"2016-03-11T17:35:01.000Z","updated":"2016-03-30T03:36:57.784Z","comments":true,"path":"2016/03/12/tech/markdown_editor/","link":"","permalink":"http://blog.12xiaoshi.com/2016/03/12/tech/markdown_editor/","excerpt":"HTML5 所见即所得 WYSIWYG (What You See Is What You Get) 编辑器的需求量是非常大的。但是现在有太多这样的编辑器了，想要从其中找到一个合适的并不容易。今天这篇文章为大家分享 10 个我认为是十分棒的所见即所得插件，应该有适合你的需求并能节省你时间的。 Froala Froala 所见即所得 HTML 编辑器非常易于整合和使用。它几乎不需要你掌握任何代码知识。它需要 jQuery 1.11.0 或者更高版本、以及 Font Awesome 4.4.0 字体图标的支持。除了整合的 UX 以及 UI 外，还提供了很好的 XSS 攻击保护。 ####特点： 文件压缩后 34K 行内编辑 支持键盘快捷键 要求基本的 HTML 和 JavaScript 知识 深浅两种主题 对移动端做了优化 支持Word 34 种语言支持以及 RTL(Right to Left) 从右向左支持","text":"HTML5 所见即所得 WYSIWYG (What You See Is What You Get) 编辑器的需求量是非常大的。但是现在有太多这样的编辑器了，想要从其中找到一个合适的并不容易。今天这篇文章为大家分享 10 个我认为是十分棒的所见即所得插件，应该有适合你的需求并能节省你时间的。 Froala Froala 所见即所得 HTML 编辑器非常易于整合和使用。它几乎不需要你掌握任何代码知识。它需要 jQuery 1.11.0 或者更高版本、以及 Font Awesome 4.4.0 字体图标的支持。除了整合的 UX 以及 UI 外，还提供了很好的 XSS 攻击保护。 ####特点： 文件压缩后 34K 行内编辑 支持键盘快捷键 要求基本的 HTML 和 JavaScript 知识 深浅两种主题 对移动端做了优化 支持Word 34 种语言支持以及 RTL(Right to Left) 从右向左支持 ContentTools ContentTools 是一个小而美的内容编辑器。该库不需要任何 JavaScript 框架或库的支持(包括 jQuery)，但是却表现很好。ContentTools 包由 5 个库组成，每一个都可以单独使用，并且该插件易于扩展。 ####特点： 压缩后 49 KB 行内编辑 可以调整图片和视频大小 支持 撤销/重做 (undo/redo) Raptor Editor Raptor Editor 是一个开源的 JavaScript 所见即所得 HTML 编辑器，对用户友好，易于集成和定制。它为行内编辑而设计，是复杂的多块布局的理想选择。它所用最新的技术如 HTML5 ContentEditable 及 jQuery ，特性有内置单元测试、模块化、可扩展及插件 API。 ####特点： 支持行内编辑 灵活的对接选项 可定制的主题 良好的文档 Aloha Aloha 是一个多功能的内容编辑库。它允许在你的 WEB 应用中无缝的嵌入编辑。主要缺点是不支持图片插入。 ####特点： 142 KB 支持WORD 跨浏览器兼容 易于定制 TinyMCE TinyMCE是一个基于 WEB 的独立的JavaScript的HTML所见即所得平台。它允许你把 HTML textarea 字段或其他元素转化为编辑器实例。它遵循 WAI-ARIA 规范，使得它适用于屏幕阅读器如JAWS 和 NVDA。它还有一个你可以得到优先支持的企业方案。 ####特点： 实时媒体嵌入 内置图像编辑 拼写检查（企业版） 支持WORD 40+ 语言支持 跨浏览器 Bootstrap3-wysiwyg Bootstrap3-wysiwyg 是一个 JavaScript 插件，由于使用 wysihtml5 及 BootStrap ，使得它是一个易用使用且漂亮的所见即所得编辑器。 ####特点： 压缩后 206 KB 支持 RequireJS 可自定义工具栏模版和主题 提供事件如 load 和 blur 。 Summernote Summernote 是一个基于 Bootstrap 的文本编辑器，提供了各种不同的主题供选择。也有一个 Material 版本的主题，叫做 MaterialNote。 ####特点： JS+CSS 共 80 KB 支持 Bootstrap 3.x.x 容易迁移到 Django, Rails 或 Angular 易于定制 CodeMirror 一体化 CKEditor CKEditor 是一个好用的 HTML 编辑器，专为简化 WEB 内容创作而设计。它把普通的文字处理工作直接带到 WEB 页面来实现。 ####特点： 使用 CKBuilder 定制而来 支持 WORD 行内编辑 撤消/重做支持 RTL(右到左)支持 支持 60 多种语言 Trumbowyg Trusmbowyg 是这里列出的编辑器中最轻便的。所有其他所见即所得编辑器都大于 45 KB，而 Trumbowyg 只有 16 KB。它要求 jQuery &gt;= 1.7。 ####特点： 只有 16KB 30 多种语言支持 Redactor Redactor 是一个快速、强大、可扩展的编辑器，它已经存在了差不多 7 年了，并且还在不断开发。它会自动把图片上传到 Amazon S3。 ####特点： 压缩后 75KB 行内编辑 支持 CodeMirror 图片拖放功能 由于该编辑器是基于插件的，所以很容易定制###总结 这篇文章中为你展示了 10 个我认为是最棒的 jQuery 和 HTML 所见即所得编辑器插件，我希望这个列表在你需要为你的项目选择文本编辑器的时候有所帮助，希望有一款能够节省你寻找的时间并且适合你的需求。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"编辑器","slug":"编辑器","permalink":"http://blog.12xiaoshi.com/tags/编辑器/"},{"name":"jquery","slug":"jquery","permalink":"http://blog.12xiaoshi.com/tags/jquery/"},{"name":"富文本编辑器","slug":"富文本编辑器","permalink":"http://blog.12xiaoshi.com/tags/富文本编辑器/"}]},{"title":"初探“十三行”服装批发市场","slug":"life/c2m_02","date":"2015-09-19T15:35:34.000Z","updated":"2015-09-19T16:40:56.223Z","comments":true,"path":"2015/09/19/life/c2m_02/","link":"","permalink":"http://blog.12xiaoshi.com/2015/09/19/life/c2m_02/","excerpt":"###篇前语这是《中国服装行业现状与困境》的第二篇，上一篇见“亟待解决的工厂生命之源”，承蒙大家厚爱，让一介码农瞬间成为一线记者，瞬间有种拍美剧大片的感觉，:-D。但，不管如何，笔者任然希望以第一视角的身份，与大家一起见证一个最真实的服装行业，笔者深信，那些所谓行业专家构想都是虚的，停留在拍脑袋的决定都是愚蠢的，深入一线才是我们要寻找的答案。 ###十三行无可否认，笔者在没来之前，完全没有听过广州十三行，相信很多行业外的朋友跟笔者一样。因此笔者在去之前特地百度了下，摘录一段（如果你之前有过了解，不妨再深入了解下，之所以摘录这段是因为它确如笔者所见所闻）:","text":"###篇前语这是《中国服装行业现状与困境》的第二篇，上一篇见“亟待解决的工厂生命之源”，承蒙大家厚爱，让一介码农瞬间成为一线记者，瞬间有种拍美剧大片的感觉，:-D。但，不管如何，笔者任然希望以第一视角的身份，与大家一起见证一个最真实的服装行业，笔者深信，那些所谓行业专家构想都是虚的，停留在拍脑袋的决定都是愚蠢的，深入一线才是我们要寻找的答案。 ###十三行无可否认，笔者在没来之前，完全没有听过广州十三行，相信很多行业外的朋友跟笔者一样。因此笔者在去之前特地百度了下，摘录一段（如果你之前有过了解，不妨再深入了解下，之所以摘录这段是因为它确如笔者所见所闻）: 位于广州市荔湾区十三行路，熟悉的人一般简称为“十三行”。如今的十三行仍然全国最大的服装批发中心。批发零售均可，以十三行路为中心，故衣街、十三行豆栏上街、和平东路服装商场环绕成的物流商业圈，已成为广州历史最长的服装批发集散地。这里每天进出货物数千吨，人流量达数十万人次，商业辐射全国各地、俄罗斯以及东南亚地区。 十三行商圈主要由新中国大厦和红遍天大厦构成。“新中国”的一楼到三楼的零售批发商铺每天早上六点半就开门做生意，四楼以上的大户则八点开门。“红遍天”一二楼也是零售批发兼做的商铺，一般也在早上六点半开门，三楼以上的写字楼生意较稳定，主要是向全国的批发大户承接“打包”生意，很少做零售，大多在七点半后才开门。 十三行服装批发市场中低档服装批发为主，其中新中国大厦写字楼的服装中高档，批发档口以中档为多。红遍天服装批发市场，豆栏街等周边批发市场多以低档为主。 每年八九月，都是十三行最旺的时段，一到换季，全国各地的服装批发商都到这里拿衣服，秋冬服装如今也已挂满了大小档口。从皮衣、针织、毛衣、套装、衬衣、牛仔系列等应有尽有，琳琅满目。在“新中国”和“红遍天”两座大厦间有条长约400米左右的路段，全部堆满了如山的货物，都是用编织袋或纸皮箱打包好的货物，等待发货。在“红遍天”和“新中国”大厦之间有一排写着全国各地城市名字的发货点，堪比省汽车站的发车处，分有省内、上海、杭州、山东、北京、石家庄、内蒙古等多个方向，还分空运和陆运等不同运输方式。在这个发货点附近，还形成了“红遍天”货运配载城等物流中心，专门做服装批发生意。 十三行以卖20~30元的货色为主，在全世界的中国制造里面，凡是能用七八十元人民币买到的衣服，几乎都能在这里找到。时装杂志里最兴的蓝色，已经取代了曾经大热的白衬衣在十三行全面开花，每个档口都有一两件“克莱因蓝”或“姣婆蓝”坐镇；当北京动物园廉价时装街的批发商纷纷挂出了平价的窝钉系列，京沪甚至韩国首尔街头出现“窝钉党”和“蓝衣党”时，制作出这些流行款式的广州人还在奋战35度高温。 十三行每天对外发货达三四千吨，只要两三天时间就能提供最新货色，一万多名时装从业者正日夜为全世界草根衣橱换季而奋战。 （“新中国”深夜踩点） ###出发昨日的疲倦并没有影响笔者和同事们的探索行程，一早便来到了十三行商圈，uber肯定是开不进来的，8点钟的人民南路早就堵成狗了。当然，下车后也不用地图导航，跟着小推车（是叫小推车？）的人流走就对了。很快，就来到了“红遍天”，构成十三行商圈之一的建筑。 （“红遍天”，抢镜者无需马赛克，:-D） （各种物流） 笔者并没有进入“红遍天”内部，选择以“新中国”大厦作为第一站。 ###“新中国”的“明察暗访”行程很明确，进入“新中国”大厦，先熟悉各楼层主要批发品类、平均批发价格、人流量，再随机对拿货的商家进行访问交流。 笔前，先要感谢各位接受笔者和同事们无尽问题的各位拿货人，虽然你们中有些人头也不回的走了，但你们的答案和行为对笔者都具有重大意义。另外要感谢一直在背后跟（tou）拍的某同学，你老辛苦了，但愿有朝一日能整理个纪录片，与全球人分享。 进入“新中国”大厦，笔者是一愣一愣的，90%以上的人群是靓女，她们上可以能说会道指点江山，下可以当众换衣不觉尴尬。不仅如此，她们掌控着女性服装的时尚潮流，你今天能穿到的抑或流行的款，都是她们独到的眼光选出来的，她们是女性服装时尚的操控者。 为什么笔者一直说崇拜这群广州的靓女，相比江浙沪的娇弱（绝无地域歧视，不服来战），她们自力更生，豪放大气。 而仅剩的不足10%的靓仔，都是“苦力工”，备货、打包、发货、运输！作为一个男人，笔者深深的觉得在这里混不下去了…… 在熟悉了‘新中国’大厦各楼层的经营情况（建议各位先看看这个）后，笔者与同事随机对几位拿货人进行了采访，依照时间顺序我定义为A、B、C、D、E（由于采访的人太多，不一定都能对上，但收集的信息一定是覆盖的）。 ####小A 小A是两位来自四川的靓女，中途坐推拉车上休息，被笔者逮住（淹没在靓女人海中的笔者，发现只有这些休息的妹子才有空隙与你闲聊，而且美女一般不会拒绝你。哎，这是笔者被拒绝N次得出来的经验）。 笔者：美女你们好，你们是来拿货的吗？能问几个问题吗？ 答：是，什么问题？ 笔者：你们拿的这些货，最后是放线上卖，还是线下实体店卖？ 答：我们是实体店。 笔者：不做淘宝或者天猫吗？ 答：不做。 笔者：你们多久来十三行一次？ 答：差不多一周来一次，至少也会一个月来三次。 笔者：你们哪里的？（笔者其实不愿意一下子就问这么隐私的问题，但这对笔者很重要呀） 答：我们四川的。（惊呆了，美女完全没有防备，豪爽的让笔者不相信呀，中西部的妹子豪爽果然不是吹的） 笔者：那你们每次来回不是很辛苦？（先套近乎） 答：是啊，每次来回大概3天时间。（心疼死笔者了，一个月要耗费7-9天时间在路上） 笔者：每次拿货很多吗？ 答：还行吧，一般在10W左右，前段时间可能少一点，有时5-6W，几千的也有。（额，笔者脑子转了很久，夏装要便宜不少） 笔者：你们有固定档口拿货吗？ 答：不会，我们只看款，感觉不错就会下单，没有固定档口。 笔者：全凭你们俩感觉？ 两美女相视一笑，是对问题的肯定，也是对自己的眼光的肯定。 笔者：会去1688之类的网上拿货吗？ 答：没有过。 笔者：为什么？ 答：图片呀，看不到。 够实在的回答，笔者第一次访谈，有点紧张，匆匆双手合十表示感谢，下电梯了。哎呀妈呀，摄（tou）影(pai)师提醒我，怎么可以连微信号这么关键的问题都忘了，再次坐上电梯，发现妹子已消失在人群中。哎，错过，就是一生。 ####小B 其实，问题与小A的问题差不多，这位来着广东的靓妹不是很配合，但依稀的收集到这些信息：进货销售到线下实体店和淘宝店，每天都会来十三行一次，广州本地人，单次进货不多。 ####小C 小C是笔者和pig同事一起访问的，认识到她是一个专门为线下实体店选款的买手，通过在十三行选中自己喜欢的款，然后通过微信等渠道发布信息，其他实体店或者淘宝店主在她这里进货。眼光，就是资本！ ####小D 小D是两位来自湖南的妹陀，做连锁，不做自己品牌，线下60家店（来这里拿货的都是很牛逼的人），不做线上，每个月至少来一次十三行，进货只看款。对线上进货表示极度的兴趣，但非常重视第一手款是否会流向普通消费者。 ####小E小E是一位来自西北的批发商，她们做的量非常大，西北片区的货大部分是她们从十三行进回去，然后从她们这里二次批发的。类似杭州四季青里面的大批发商。 ###总结一个上午，笔者和小伙伴们走访了新中国大厦以及周边服装批发圈，访问了形形色色的拿货人，稍微做下总结： 来十三行拿货的人群各式各样，有大型批发商，有线下实体店主，有淘宝店主，也有网络红人等，总体以偏传统的线下实体店为主。（在拜访的人群中，做线上的很少，阿里巴巴到底解决了“让天下没有难做的生意”吗？） 进到的货，零售的价格基本都是400元以下款； 新款对这些进货者至关重要，但不排斥通过互联网方式进货，关键在于是不是第一手； 品牌的概念在十三行无关重要，这些提货者要么自己回家贴牌，要么直接进行零售； 其他二三线城市，甚至像北京动物园、杭州四季青等大型档口，从十三行拿货的人也不少； 这里是女人的天下。 夜已深，惊闻上海慕和网络CEO吴波去世，意识到健康的重要性，笔者也打算睡去，敬请期待下一篇，愿逝者一路走好。","categories":[],"tags":[{"name":"中国制造","slug":"中国制造","permalink":"http://blog.12xiaoshi.com/tags/中国制造/"},{"name":"十三行","slug":"十三行","permalink":"http://blog.12xiaoshi.com/tags/十三行/"},{"name":"C2M","slug":"C2M","permalink":"http://blog.12xiaoshi.com/tags/C2M/"},{"name":"你造么","slug":"你造么","permalink":"http://blog.12xiaoshi.com/tags/你造么/"},{"name":"广州服装批发市场","slug":"广州服装批发市场","permalink":"http://blog.12xiaoshi.com/tags/广州服装批发市场/"},{"name":"新中国大厦","slug":"新中国大厦","permalink":"http://blog.12xiaoshi.com/tags/新中国大厦/"}]},{"title":"广州十三行新中国大厦各楼层服装批发货源详细解说","slug":"life/newchina_intro","date":"2015-09-18T03:54:01.000Z","updated":"2015-09-19T13:36:48.227Z","comments":true,"path":"2015/09/18/life/newchina_intro/","link":"","permalink":"http://blog.12xiaoshi.com/2015/09/18/life/newchina_intro/","excerpt":"广州十三行新中国大厦服装批发各楼层货源： 1楼是散档口，一个档口只有2-10个平方，厂家一般只挂5-10个款，主要做单品，就是做T的专门做T, 做裙子的专门做裙子。在进货价格一般在 20-60之间，基本超过60的相当少了。主要做中低档杂志款，时尚流行的款式，呵呵，说的确切点就是以抄版 为主。网络上流行什么，杂志款流行什么，他们就做什么。更新特别快。主要以跑量为主。 但做工非常一般，亲们要注意哦。～1楼右侧 有几十个档口主要做饰品，腰带，鞋，配饰等。这里有部分虽然不是厂家，但一般少量拿一些搭配用，价格还是很合理的。","text":"广州十三行新中国大厦服装批发各楼层货源： 1楼是散档口，一个档口只有2-10个平方，厂家一般只挂5-10个款，主要做单品，就是做T的专门做T, 做裙子的专门做裙子。在进货价格一般在 20-60之间，基本超过60的相当少了。主要做中低档杂志款，时尚流行的款式，呵呵，说的确切点就是以抄版 为主。网络上流行什么，杂志款流行什么，他们就做什么。更新特别快。主要以跑量为主。 但做工非常一般，亲们要注意哦。～1楼右侧 有几十个档口主要做饰品，腰带，鞋，配饰等。这里有部分虽然不是厂家，但一般少量拿一些搭配用，价格还是很合理的。 2楼也是散档口，面积跟一楼差不多，档次和风格都差不多，一般进货从一楼直接往上走，就没错了。2楼右手边有几十个档口是做包包批发的哦，都是当季的最新款，价格也不高，拿货价在30-80之间。呵呵，有的质量还不错哦。值得亲们注意的是二楼有一个C区是专门做裤子的，休闲裤，牛仔裤批发，价格在20-50之间。要拿便宜裤子的亲们，要记住哦。十三行不像白马，成风格和体系，这里很多家只做单品，需要跑很多家才能找到自己的货源～～ 3楼也是散档口跟一楼二楼 都差不多，不过三楼比较杂，建议拿时尚型的亲可以在一楼二楼 。 4楼主要是写字楼，要比1-3楼档次高一些，档口面积和开销也大一些，呵呵，当然衣服也要贵一些哦！不过木木一直认为四楼很杂，没有具体风格，这里拿货价在35-80之间。有几家是专门做帽子的还不错，其它 确实没有值得推荐的地方哦。 5楼主要是写字楼，重点介绍一下，做牛仔裤的亲们要注意了！五楼基本上都是做牛仔裤的厂家，中档牛仔裤，现在慢慢也偏向中高档了，拿货价在50-130哦，去年的时候我记得还有50多价位的。这里亲可以货比三家，根据自己的风格和价位来挑选哦，不过有点麻烦的是，牛仔裤码数太多，压货量是可想而知的。建议亲们要理性对待，看准了再下手。 6楼主要是写字楼，连衣裙批发，T这些全部都有，档次比1-3楼要高，拿货价在40-100之间了。今年的连衣裙一般都在60-95之间了，6楼也有一些韩国人的档口哦，虽然价格偏高一点，但做工都不错的。亲们可以好好转转。韩国档口的款式，一般都是韩国流行的款式，很不错。 7楼主要是写字楼，各类产品都有，档次跟六楼差不多，价格和风格都差不多。 8楼，9楼，10楼主要是写字楼，重点介绍，呵呵，这一层也是我们跑的最多的地方，因为3层聚集了十三行最优质的供应商。当然这三层的房租也是十三行最贵的。人流量 也是最大的。这几层款式更新很快。属于正宗的中高档女装。质量都不错。风格都是少女型 ，少妇型都有。这个没有分明显的区，需要自己找。不过现在拿货价也都在50-120之间。白马有很多厂家都是来这几层抄货的。款式更新快，价格比白马要便宜一半，也正是看中这一利益。这三层中，有香港老板，台湾老板，韩国老板，也有内地的。呵呵，想想吧，亲，这三个地方的人可都是对质量要求严格的哦。样版很多都是从他们当地发过来的，所以款式更新特别快，紧跟潮流。 11楼，12楼 是有一些不错的厂家，亲有时间的话，不防上来看看。价格比8-9-10要低一些。是呢，人越是多，生意越好，房租也就越贵，这都是成正比的。但跟款式和质量也是离不开的哦。 13楼是防空层，呵呵，如果步行走楼梯的话，要注意哦，有个隔层直接上14层。 14-15-16-17-18-19-20这些楼层，主要是跑大量的。款式更新相对慢一些。新手卖家不建议去上面拿货。风格偏土气一点，如果做这一类型的亲可以上去看看的。但也有一些偏时尚的厂家的，要慢慢找。裤子，T,裙子也都有。我们上去的较少，不过亲有兴趣可以去看看。当然这上面也比较冷清，因为一般厂家在全国都有代理商，只用发货就行了，在档口不销售的。当然上面的房租要比下面便宜一倍多呢。所以衣服也便宜一些。想做便宜货的亲们，不防来看看。 广州十三行新中国大厦这20层的基本情况就是这样，亲们可以仔细看一看，如果都清楚了，我想，你就不会再想无头苍蝇一样，一进市场就疯狂拿货了。这样，你可以根据自己的定位和风格，找准自己想要的货源再下手。","categories":[],"tags":[{"name":"中国制造","slug":"中国制造","permalink":"http://blog.12xiaoshi.com/tags/中国制造/"},{"name":"广州服装批发市场","slug":"广州服装批发市场","permalink":"http://blog.12xiaoshi.com/tags/广州服装批发市场/"},{"name":"新中国大厦","slug":"新中国大厦","permalink":"http://blog.12xiaoshi.com/tags/新中国大厦/"},{"name":"十三行，批发楼层说明","slug":"十三行，批发楼层说明","permalink":"http://blog.12xiaoshi.com/tags/十三行，批发楼层说明/"}]},{"title":"中国服装行业现状与困境（一）","slug":"life/c2m","date":"2015-09-17T21:35:01.000Z","updated":"2015-09-19T05:10:30.692Z","comments":true,"path":"2015/09/18/life/c2m/","link":"","permalink":"http://blog.12xiaoshi.com/2015/09/18/life/c2m/","excerpt":"###写之前2015年9月16日凌晨5点，迎着杭州秋意渐浓的寒风，笔者与同事们踏上了南下的飞机，前往这个传说中最大的服装生产基地，中国的南大门——广州，进行了紧促而又意义的2天探索之旅。过程是疲惫的，但，心是震撼的，感情是复杂的。 震撼的内心让一个从未接触该行业的人久久不能平息，托着疲倦的身体下了飞机，回到家里，打开最爱的DELL XPS13，以码代码的速度，在Markdown中码起了这篇文章。笔者分享的目的，是希望自己亲身的经历，能让你有所收获，甚至感同身受。 不仅如此，笔者更希望看到的是，能诞生一种新的互联网平台来驱动中国的服装制造业，重塑电商新模式。","text":"###写之前2015年9月16日凌晨5点，迎着杭州秋意渐浓的寒风，笔者与同事们踏上了南下的飞机，前往这个传说中最大的服装生产基地，中国的南大门——广州，进行了紧促而又意义的2天探索之旅。过程是疲惫的，但，心是震撼的，感情是复杂的。 震撼的内心让一个从未接触该行业的人久久不能平息，托着疲倦的身体下了飞机，回到家里，打开最爱的DELL XPS13，以码代码的速度，在Markdown中码起了这篇文章。笔者分享的目的，是希望自己亲身的经历，能让你有所收获，甚至感同身受。 不仅如此，笔者更希望看到的是，能诞生一种新的互联网平台来驱动中国的服装制造业，重塑电商新模式。 ###特别声明 这是一篇笔者的亲身经历与感悟，不代表任何个人或公司观点； 笔者乃一介码农，非业界大师，无法指点江山，文章全凭个人经历与感悟，若你对文中观点有任何异议或者有自己想法，欢迎指教； 文中若有伤到友商或朋友，请及时联系笔者，笔者在原则内可做适当修改； 本文谢绝不留名的转载，否则写代码诅咒你。 为了方便阅读，笔者按照拜访的时间，将文章分成了几个部分：亟待解决的工厂生命之源、从“新中国十三行”看服装批发市场、档口老板娘的生存经验、一种新的互联网平台模式的思考。 ###亟待解决的工厂生命之源 笔者此行安排了多家工厂，他们不是国际大厂，都属于中小型工厂，笔者定义中小型工厂的标准是工厂单天独立生产能力不高于5000件（当然，这个肯定不是说简单易做的T恤）。根据实际拜访结果，笔者挑选其中四家具有代表性的工厂，与各位分享，暂且分别定义其为A、B、C、D。 TIPS：深入了解工厂之前，建议先阅读下“服装制作之衣衣诞生记 爆服装生产全过程（图解）”这篇文章，这样你就不会一头雾水。 ####工厂A，一家与互联网赛跑的工厂 工厂A，位于白云区，主要生产女装，固有工人50-70人，具有自己的板房、厂房、仓库、模特拍照室以及电商部门，也是笔者接触的唯一一家“什么都做”的工厂。 他们做淘工厂，这是他们约30%的生产订单来源，他们是淘工厂珠三角地区的佼佼者，对淘工厂总体评价还不错； 他们主要的订单来源来自于线下批发商和零售商，这些订单占据他们出厂订单的60%多； 他们做天猫，尝试自主品牌的运营之路，但只见烧钱没见产出，自己的爆款设计款也曾被竞争者抄袭而无奈，线上运营经验几乎为0，对空降的运营疯狂直通车表示恐慌，但又不想丢掉天猫这块“肥肉”； 他们做美丽说，但感觉美丽说到处是坑，他们隐约觉得美丽员工急于上市数据暗示他们进行刷单（但笔者觉得，有那个电商平台没刷单呢）; 他们也做蘑菇街，给蘑菇街的是好评（笔者真不是蘑菇街的托）； 他们1年前也做京东，但京东的资金流转太慢，他们选择退出。然，京东押金至今没有退还。话说东哥，奶茶你也喝到了，不求做你的上帝，作为一个普通消费者，真想问：你们的员工能让你做一回真男人么？ 他们也接受到淘宝中国质造的邀请，尝试来中国质造玩一把，他们说，淘宝的中国质造的工厂就是1688的淘工厂旧部，中国质造到底怎么走，也是一头雾水，笔者算是大开眼界。 (工厂A模特拍照室一角) (工厂A厂房一角) 工厂A是笔者接触的第一家工厂，对于行业的小白来说，瞬间觉得脑子快装不下了，不过这比写代码有趣多了。工厂A曾经也为妖精的口袋之类的淘宝大卖家代工。 老板，没错，是个女的,年龄目测与笔者相仿（纯属猜测，若猜大了就一笑而过吧，:-D）,低调而具有掌控全局的能力，广州的女人都TM是笔者的偶像（看完该文全部系列就知道笔者为什么这么说了）。 (工厂A一角与老板娘合影) 业务聊毕，老板娘盛情款待了我们，真是托了“pig同事”的福，哎，一个看脸的时代！工厂附近依然能吃到广州各式特产（话说，吃饭前拿茶水洗碗，再倒进一个专门的盆，笔者给跪了！！算广州特产么？）。 ####工厂B，“服装生产基地”中的线上针织专注者 白云区拜访完毕，笔者和同事们没一刻的停留，来到了海珠区，他们说，这里是一片服装生产的沃土。 然而这里不是高大明亮的办公厂房和生产环境，也不是政府资金的重点扶持区块，不信笔者带你领略下。 (小巷里三轮车装着面料在人潮中穿梭） 然，笔者拜访的工厂B就位于鹭江西街的一块杂乱区。笔者一路走进来（打uber都开不进来，看照片，:-D），也是着实被这场面给吓到了！直到我们与工厂B的老板（没错，她也是女的，依旧是笔者差不多的年龄，可能更小）交流，才醒悟到我们的肤浅，这是个看脸的时代，这不是看脸的小巷！ 海珠区隶属服装生产历史老区，在这块区域，工厂可以以最快的速度拿到面料、辅料，因为这里有广东地区最高效的面料纺织供应商，即使没有现成的面料，下午下单一个晚上的印染等做工第二天就可以拿来厂房生产。这块区域已经形成了社会化生产、柔性化供应链甚至于个性化营销于一体的特色生产区。人群多样性造就了海珠区这带的多样性，也塑造了海珠区服装生产企业的另一番景象。 所以，工厂B的特点非常明显： 只做淘工厂的订单，很少接线下订单，订单来源几乎全部依赖淘工厂； 只做针织，不做梭织（关于针织梭织笔者也是学习了半天才明白，想学习的自己百度吧），机器不同，做工过程不同，针织更易对工人更有力； 工厂不大，工人目测不超过20人，能快速反应，一般1000件以下，3-5天出货； 不限订单量 BTW，中途得知，工厂门口堆放的库存是网易游戏的T恤。 ####工厂C，传统的服装生产工厂 是的，笔者和同事们马不停蹄的来到番禹区兴业大道这边，拜访了工厂C，一个稍具规模的工厂，目测全部上岗工人在100+（即使现在是服装生产旺季，他们还是有部分工人没有订单可做，处于“休假”状态）。 该工厂主要订单来源来自大批发商，一般一次可能在500件+，曾为韩都衣舍等代工。也许离市区较远，所以厂房较大，整理的较整齐。由于外贸订单的下滑，工人“休假”在所难免，听完也让笔者一阵凉风吹过，工厂的改革迫在眉睫。 ####工厂D，只做代工的工厂工厂D是一家纯做加工的工厂，它没有设计师，没有打板师，纯拿订单做苦力，即使有设计稿或图纸，是交给外面的专业打板师傅进行打板设计。 ####工厂共同特点 以上四家工厂，都是各具特点的工厂，这么多工厂拜访下来，笔者总结工厂的共性： 工厂的生命，就是订单，订单量始终是工厂赖以生存的关键； 中小型工厂基本可以接受的起订量标准就是一条布的量（比如一条布可以生产100件T恤）； 工厂大部分都是一起合作，订单只怕少不怕多，多订单会分给兄弟工厂一起完成； 一般的工厂，都具有自己打板的能力，稍具规模的工厂都有自己的设计师，但都极其不愿意自己设计，而更喜欢客户直接拿设计稿或样板来，工厂实现打板； 工厂打板只是为了订单做附加服务，但打板不一定是工厂的核心，工厂不是非常乐意多次来回修版，其实就好比互联网的产品经理的角色一样； 工厂最擅长的始终是生产，对于类似电商模式的售后流程，是大多传统工厂不太愿意触碰的，也是他们人力物力目前做不到的； 大工厂不会理会小订单，大工厂也没时间来理会小订单。 到这里，笔者已深深的体会到中小型工厂的不容易，看似繁华穿梭的人群，确是一种生存的无奈，内心的针扎。 工厂A在各种网络平台中追随电商的脚本，尝试做先驱，但很有可能成为先烈；工厂B定位只做网络订单，但谁知道拥有浩海资源的阿里巴巴，小小的淘工厂是否能成大器；工厂C、D，传统订单渠道整体下滑，工人们要生活，传统工厂的转型之路到底何去何从。 不想在首篇就开始大刀阔斧，请与笔者一起，接下一篇，感受新中国十三行的“繁华”。","categories":[],"tags":[{"name":"广州服装","slug":"广州服装","permalink":"http://blog.12xiaoshi.com/tags/广州服装/"},{"name":"工厂","slug":"工厂","permalink":"http://blog.12xiaoshi.com/tags/工厂/"},{"name":"中国制造","slug":"中国制造","permalink":"http://blog.12xiaoshi.com/tags/中国制造/"},{"name":"十三行","slug":"十三行","permalink":"http://blog.12xiaoshi.com/tags/十三行/"},{"name":"C2M","slug":"C2M","permalink":"http://blog.12xiaoshi.com/tags/C2M/"},{"name":"你造么","slug":"你造么","permalink":"http://blog.12xiaoshi.com/tags/你造么/"}]},{"title":"Lazy Load, 延迟加载图片的 jQuery 插件","slug":"tech/image_lazy_load","date":"2015-09-03T16:35:01.000Z","updated":"2015-09-04T06:28:40.340Z","comments":true,"path":"2015/09/04/tech/image_lazy_load/","link":"","permalink":"http://blog.12xiaoshi.com/2015/09/04/tech/image_lazy_load/","excerpt":"本文翻译自 Lazy Load Plugin for jQuery, 介绍一个 jQuery 插件, 它提供懒汉式加载页面图片的功能. Lazy Load 是一个用 JavaScript 编写的 jQuery 插件. 它可以延迟加载长页面中的图片. 在浏览器可视区域外的图片不会被载入, 直到用户将页面滚动到它们所在的位置. 这与图片预加载的处理方式正好是相反的. 在包含很多大图片长页面中延迟加载图片可以加快页面加载速度. 浏览器将会在加载可见图片之后即进入就绪状态. 在某些情况下还可以帮助降低服务器负担. Lazy Load 灵感来自 Matt Mlinac 制作的 YUI ImageLoader 工具箱. 这是演示页面. 这里有几个可用的 demo 页面提供给那些匆忙的人参考: 基本选项, 淡入展示效果, script 脚本缺失的降级处理, 水平滚动, 容器内水平滚动, 容器内垂直滚动, 页面内存在超多图片, 延时加载图片 查看 demo 中每个请求间浏览器缓存的内容. 你可以通过开发者控制台 (Chrome 和 Safari), Firebug (Firefox) 或者 HTTPHeaders (IE) 检测到实际加载的内容.","text":"本文翻译自 Lazy Load Plugin for jQuery, 介绍一个 jQuery 插件, 它提供懒汉式加载页面图片的功能. Lazy Load 是一个用 JavaScript 编写的 jQuery 插件. 它可以延迟加载长页面中的图片. 在浏览器可视区域外的图片不会被载入, 直到用户将页面滚动到它们所在的位置. 这与图片预加载的处理方式正好是相反的. 在包含很多大图片长页面中延迟加载图片可以加快页面加载速度. 浏览器将会在加载可见图片之后即进入就绪状态. 在某些情况下还可以帮助降低服务器负担. Lazy Load 灵感来自 Matt Mlinac 制作的 YUI ImageLoader 工具箱. 这是演示页面. 这里有几个可用的 demo 页面提供给那些匆忙的人参考: 基本选项, 淡入展示效果, script 脚本缺失的降级处理, 水平滚动, 容器内水平滚动, 容器内垂直滚动, 页面内存在超多图片, 延时加载图片 查看 demo 中每个请求间浏览器缓存的内容. 你可以通过开发者控制台 (Chrome 和 Safari), Firebug (Firefox) 或者 HTTPHeaders (IE) 检测到实际加载的内容. ###怎样使用Lazy Load 依赖于 jQuery. 请将下列代码加入页面 head 区域: &lt;script src=&quot;jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery.lazyload.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; 你必须修改 HTML 代码. 在 src属性中设置展位符图片, demo 页面使用 1x1 像素灰色 GIF 图片. 并且需要将真实图片的 URL 设置到 data-original 属性. 这里可以定义特定的 class 以获得需要延迟加载的图片对象. 通过这种方法你可以简单地控制插件绑定. &lt;img class=&quot;lazy&quot; src=&quot;img/grey.gif&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; heigh=&quot;480&quot;&gt; 处理图片的代码如下. $(&quot;img.lazy&quot;).lazyload(); 这将使所有 class 为 lazy 的图片将被延迟加载. 可以参考基本选项 demo ###设置敏感度 几乎所有浏览器的 JavaScript 都是激活的. 然而可能你仍希望能在不支持 JavaScript 的客户端展示真实图片. 当浏览器不支持 JavaScript 时优雅降级, 你可以将真实的图片片段在写 &lt;noscript&gt;标签内. &lt;img class=&quot;lazy&quot; src=&quot;img/grey.gif&quot; data-original=&quot;img/example.jpg&quot; width=&quot;640&quot; heigh=&quot;480&quot;&gt; &lt;noscript&gt;&lt;img src=&quot;img/example.jpg&quot; width=&quot;640&quot; heigh=&quot;480&quot;&gt;&lt;/noscript&gt; 可以通过 CSS 隐藏占位符. .lazy { display: none; } 在支持 JavaScript 的浏览器中, 你必须在 DOM ready 时将占位符显示出来, 这可以在插件初始化的同时完成. $(&quot;img.lazy&quot;).show().lazyload(); 这些都是可选的, 但如果你希望插件平稳降级这些都是应该做的. ###设置敏感度 默认情况下图片会出现在屏幕时加载. 如果你想提前加载图片, 可以设置 threshold 选项, 设置 threshold 为 200 令图片在距离屏幕 200 像素时提前加载. $(&quot;img.lazy&quot;).lazyload({ threshold : 200 }); ###占位图片 你还可以设定一个占位图片并定义事件来触发加载动作. 这时需要为占位图片设定一个 URL 地址. 透明, 灰色和白色的 1x1 象素的图片已经包含在插件里面. ###事件触发加载 事件可以是任何 jQuery 时间, 如: click 和 mouseover. 你还可以使用自定义的事件, 如: sporty 和 foobar. 默认情况下处于等待状态, 直到用户滚动到窗口上图片所在位置. 在灰色占位图片被点击之前阻止加载图片, 你可以这样做: $(&quot;img&quot;).lazyload({ placeholder : &quot;img/grey.gif&quot;, event : &quot;click&quot; }); ###使用特效 当图片完全加载的时候, 插件默认地使用 show()方法来将图显示出来. 其实你可以使用任何你想用的特效来处理. 下面的代码使用 FadeIn 效果. 这是效果演示页面. $(&quot;img.lazy&quot;).lazyload({ effect : &quot;fadeIn&quot; }); ##图片在容器里面 你可以将插件用在可滚动容器的图片上, 例如带滚动条的 DIV 元素. 你要做的只是将容器定义为 jQuery 对象并作为参数传到初始化方法里面. 这是水平滚动演示页面和垂直滚动的演示页面. #container { height: 600px; overflow: scroll; } $(&quot;img.lazy&quot;).lazyload({ container: $(&quot;#container&quot;) }); ###当图片不顺序排列 滚动页面的时候, Lazy Load 会循环为加载的图片. 在循环中检测图片是否在可视区域内. 默认情况下在找到第一张不在可见区域的图片时停止循环. 图片被认为是流式分布的, 图片在页面中的次序和 HTML 代码中次序相同. 但是在一些布局中, 这样的假设是不成立的. 不过你可以通过 failurelimit 选项来控制加载行为. $(&quot;img.lazy&quot;).lazyload({ failure_limit : 10 }); 将 failurelimit 设为 10 令插件找到 10 个不在可见区域的图片是才停止搜索. 如果你有一个猥琐的布局, 请把这个参数设高一点. ###延迟加载图片 Lazy Load 插件的一个不完整的功能, 但是这也能用来实现图片的延迟加载. 下面的代码实现了页面加载完成后再加载. 页面加载完成 5 秒后, 指定区域内的图片会自动进行加载. 这是延迟加载演示页面. $(function() { $(&quot;img:below-the-fold&quot;).lazyload({ event : &quot;sporty&quot; }); }); $(window).bind(&quot;load&quot;, function() { var timeout = setTimeout(function() {$(&quot;img.lazy&quot;).trigger(&quot;sporty&quot;)}, 5000); }); ###加载隐藏的图片 可能在你的页面上埋藏可很多隐藏的图片. 比如插件用在对列表的筛选, 你可以不断地修改列表中各条目的显示状态. 为了提升性能, Lazy Load 默认忽略了隐藏图片. 如果你想要加载隐藏图片, 请将 skip_invisible 设为 false $(&quot;img.lazy&quot;).lazyload({ skip_invisible : false }); ###下载插件 最新版本 源代码和压缩的代码. 插件已经在 OSX 的 Safari 5.1, Safari 6, Chrome 20, Firefox 12 浏览器上, Windows 的 Chrome 20, IE 8 and IE 9 浏览器上, 以及 iOS5 (iPhone 和 iPad) 的 Safari 5.1 浏览器上测试过.","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"jQuery","slug":"jQuery","permalink":"http://blog.12xiaoshi.com/tags/jQuery/"},{"name":"Lazy Load","slug":"Lazy-Load","permalink":"http://blog.12xiaoshi.com/tags/Lazy-Load/"},{"name":"延迟加载","slug":"延迟加载","permalink":"http://blog.12xiaoshi.com/tags/延迟加载/"}]},{"title":"实现在Quartz中使用Spring的@Autowire注入Bean对象","slug":"tech/spring_quartz_autowire","date":"2015-06-28T14:50:01.000Z","updated":"2017-08-17T09:38:08.028Z","comments":true,"path":"2015/06/28/tech/spring_quartz_autowire/","link":"","permalink":"http://blog.12xiaoshi.com/2015/06/28/tech/spring_quartz_autowire/","excerpt":"&lt;bean id=&quot;customSpringBeanJobFactory&quot; class=&quot;com.nzaom.server.job.CustomSpringBeanJobFactory&quot;/&gt; &lt;bean id=&quot;itemEndTimeOverJob&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt; &lt;property name=&quot;jobClass&quot; value=&quot;com.nzaom.server.job.ItemEndTimeOverJob&quot; /&gt; &lt;property name=&quot;durability&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetails&quot;&gt; &lt;list&gt;&lt;ref bean=&quot;itemEndTimeOverJob&quot; /&gt;&lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;itemEndTimeOverJob&quot; /&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0 0/1 * * * ?&quot; /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;jobFactory&quot; ref=&quot;customSpringBeanJobFactory&quot;/&gt; &lt;/bean&gt;","text":"&lt;bean id=&quot;customSpringBeanJobFactory&quot; class=&quot;com.nzaom.server.job.CustomSpringBeanJobFactory&quot;/&gt; &lt;bean id=&quot;itemEndTimeOverJob&quot; class=&quot;org.springframework.scheduling.quartz.JobDetailFactoryBean&quot;&gt; &lt;property name=&quot;jobClass&quot; value=&quot;com.nzaom.server.job.ItemEndTimeOverJob&quot; /&gt; &lt;property name=&quot;durability&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.SchedulerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetails&quot;&gt; &lt;list&gt;&lt;ref bean=&quot;itemEndTimeOverJob&quot; /&gt;&lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;triggers&quot;&gt; &lt;list&gt; &lt;bean class=&quot;org.springframework.scheduling.quartz.CronTriggerFactoryBean&quot;&gt; &lt;property name=&quot;jobDetail&quot; ref=&quot;itemEndTimeOverJob&quot; /&gt; &lt;property name=&quot;cronExpression&quot; value=&quot;0 0/1 * * * ?&quot; /&gt; &lt;/bean&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;jobFactory&quot; ref=&quot;customSpringBeanJobFactory&quot;/&gt; &lt;/bean&gt; package com.nzaom.server.job; import org.quartz.spi.TriggerFiredBundle; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.config.AutowireCapableBeanFactory; import org.springframework.scheduling.quartz.SpringBeanJobFactory; /** * 实现支持在Quartz中使用Autowire注入 * @author kalman03 */ public class CustomSpringBeanJobFactory extends SpringBeanJobFactory { @Autowired private AutowireCapableBeanFactory autowireCapableBeanFactory; @Override protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception { Object jobInstance = super.createJobInstance(bundle); autowireCapableBeanFactory.autowireBean(jobInstance); return jobInstance; } }","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"Quartz","slug":"Quartz","permalink":"http://blog.12xiaoshi.com/tags/Quartz/"},{"name":"Autowire","slug":"Autowire","permalink":"http://blog.12xiaoshi.com/tags/Autowire/"},{"name":"spring","slug":"spring","permalink":"http://blog.12xiaoshi.com/tags/spring/"}]},{"title":"记录阿里云ECS服务器Java开发环境的搭建过程","slug":"tech/aliyun_esc_java_env_records","date":"2015-06-13T17:35:01.000Z","updated":"2015-06-13T17:22:17.663Z","comments":true,"path":"2015/06/14/tech/aliyun_esc_java_env_records/","link":"","permalink":"http://blog.12xiaoshi.com/2015/06/14/tech/aliyun_esc_java_env_records/","excerpt":"1、新增用户admin，添加权限到wheel组adduser admin passwd admin gpasswd -a admin wheel 参考：https://www.digitalocean.com/community/tutorials/initial-server-setup-with-centos-7 2、更新yum源参考：http://help.aliyun.com/knowledge_detail.htm?knowledgeId=5974184 yum update","text":"1、新增用户admin，添加权限到wheel组adduser admin passwd admin gpasswd -a admin wheel 参考：https://www.digitalocean.com/community/tutorials/initial-server-setup-with-centos-7 2、更新yum源参考：http://help.aliyun.com/knowledge_detail.htm?knowledgeId=5974184 yum update 3、安装nginxyum install nginx 配置文件路径：/etc/nginx 4、systemctl 指令http://cnzhx.net/blog/centos-7-rhel-7-systemd-commands/ 5、Java环境安装wget --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie;&quot; http://download.oracle.com/otn-pub/java/jdk/8u45-b14/jdk-8u45-linux-x64.rpm rpm -ivh jdk-8u45-linux-x64.rpm /usr/java/jdk1.8.0_45 vi /etc/profile export JAVA_HOME=/usr/java/jdk1.8.0_45 export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin source /etc/profile 6、Tomcat的安装和配置cd /usr wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-8/v8.0.23/bin/apache-tomcat-8.0.23.tar.gz tar -xzvf apache-tomcat-8.0.23.tar.gz 安装目录：/usr/apache-tomcat-8.0.23 配置： &lt;Host name=&quot;localhost&quot; appBase=&quot;/home/admin/webapps&quot; unpackWARs=&quot;true&quot; autoDeploy=&quot;true&quot;&gt; &lt;Context path=&quot;/&quot; docBase=&quot;application&quot; reloadable=&quot;true&quot;/&gt; &lt;/Host&gt; 7、一些便捷操作ln -s /usr/apache-tomcat-8.0.23/bin/startup.sh /home/admin/bin/start_tomcat.sh ln -s /usr/apache-tomcat-8.0.23/bin/shutdown.sh /home/admin/bin/stop_tomcat.sh ln -s /usr/apache-tomcat-8.0.23/logs /home/admin/logs/tomcat nginx_status.sh: #!/bin/sh exec /bin/systemctl status nginx.service restart_nginx.sh： #!/bin/sh exec /bin/systemctl restart nginx.service nginx_stop.sh: #!/bin/sh exec /bin/systemctl stop nginx.service 8、nginx配置/etc/nginx/nginx.conf: user nginx; worker_processes 4; error_log /home/admin/logs/nginx/error.log; pid /run/nginx.pid; events { worker_connections 10240; } http { include /etc/nginx/mime.types; default_type application/octet-stream; log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos; &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos; &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;; access_log /home/admin/logs/nginx/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; gzip on; index index.html index.htm; upstream tomcat_server{ server 127.0.0.1:8080 weight=1; } include /etc/nginx/conf.d/*.conf; } /etc/nginx/conf.d/www.nzaom.com.conf: server { listen 80 default_server; server_name www.nzaom.com nzaom.com nzaom.hehuyou.com; charset utf-8; access_log /home/admin/logs/nginx/access.log main; location / { root /home/admin/webapps; proxy_pass http://tomcat_server; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; } error_page 404 /error.htm; # redirect server error pages to the static page /50x.html # } 以上这些都是基础配置，相关参数还待优化。当然，进入了Java的世界，你永远少不了更复杂的配置，这些将会在日后的开发过程中遇到。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"nginx-tomcat-java","slug":"nginx-tomcat-java","permalink":"http://blog.12xiaoshi.com/tags/nginx-tomcat-java/"},{"name":"ECS","slug":"ECS","permalink":"http://blog.12xiaoshi.com/tags/ECS/"},{"name":"阿里云","slug":"阿里云","permalink":"http://blog.12xiaoshi.com/tags/阿里云/"}]},{"title":"基于HandlerExceptionResolver的异常解决方案","slug":"tech/springmvc_exception_json","date":"2015-06-13T16:35:01.000Z","updated":"2015-06-13T16:38:00.690Z","comments":true,"path":"2015/06/14/tech/springmvc_exception_json/","link":"","permalink":"http://blog.12xiaoshi.com/2015/06/14/tech/springmvc_exception_json/","excerpt":"用到Spring Mvc框架，不知道是否有更好的方式，来统一处理业务异常。老夫采用的是继承HandlerExceptionResolver，来实现统一的异常处理。其实这个很简单，有点意思的是可以兼容不同的View，比如这个处理类需要支持返回json，也需要支持渲染一个页面。 所以就有了这样的写法。","text":"用到Spring Mvc框架，不知道是否有更好的方式，来统一处理业务异常。老夫采用的是继承HandlerExceptionResolver，来实现统一的异常处理。其实这个很简单，有点意思的是可以兼容不同的View，比如这个处理类需要支持返回json，也需要支持渲染一个页面。 所以就有了这样的写法。 import java.util.Map; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.web.bind.annotation.ResponseBody; import org.springframework.web.method.HandlerMethod; import org.springframework.web.servlet.HandlerExceptionResolver; import org.springframework.web.servlet.ModelAndView; import com.google.common.collect.Maps; /** * @author kalman03 **/ public class CustomerExceptionResolver implements HandlerExceptionResolver { private final static Logger log = LoggerFactory.getLogger(CustomerExceptionResolver.class); @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) { log.error(&quot;Catch a exception.&quot;,ex); HandlerMethod method = (HandlerMethod) handler; ResponseBody body = method.getMethodAnnotation(ResponseBody.class); if(body != null){ GsonJsonView gsonJsonView = new GsonJsonView(); Map&lt;String, Object&gt; attributes = Maps.newHashMap(); attributes.put(&quot;success&quot;, false); attributes.put(&quot;msg&quot;, &quot;系统错误，请稍后再试&quot;); return new ModelAndView(gsonJsonView,attributes); } int status = response.getStatus(); Map&lt;String, Object&gt; model = Maps.newHashMap(); model.put(&quot;statusCode&quot;, status); model.put(&quot;exception&quot;, ex); return new ModelAndView(&quot;error&quot;, model); } } 当返回类型声明为@ResponseBody，老夫认为其返回结果是application/json，按照json的返回结果处理。 基于GSON的GsonJsonView的代码： import java.io.ByteArrayOutputStream; import java.io.OutputStream; import java.nio.charset.Charset; import java.util.HashMap; import java.util.Map; import java.util.Set; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.util.CollectionUtils; import org.springframework.validation.BindingResult; import org.springframework.web.servlet.view.AbstractView; import com.google.gson.Gson; import com.google.gson.GsonBuilder; /** * @author kalman03 */ public class GsonJsonView extends AbstractView{ private Gson gson = new GsonBuilder().create(); public static final String DEFAULT_CONTENT_TYPE = &quot;application/json&quot;; public final static Charset UTF8 = Charset.forName(&quot;UTF-8&quot;); private Charset charset = UTF8; private Set&lt;String&gt; renderedAttributes; private boolean disableCaching = true; private boolean updateContentLength = false; private boolean extractValueFromSingleKeyModel = false; public GsonJsonView(){ setContentType(DEFAULT_CONTENT_TYPE); setExposePathVariables(false); } public void setRenderedAttributes(Set&lt;String&gt; renderedAttributes) { this.renderedAttributes = renderedAttributes; } public Charset getCharset() { return this.charset; } public void setCharset(Charset charset) { this.charset = charset; } public boolean isExtractValueFromSingleKeyModel() { return extractValueFromSingleKeyModel; } public void setExtractValueFromSingleKeyModel(boolean extractValueFromSingleKeyModel) { this.extractValueFromSingleKeyModel = extractValueFromSingleKeyModel; } @Override protected void renderMergedOutputModel(Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception { Object value = filterModel(model); String text = gson.toJson(value); byte[] bytes = text.getBytes(charset); OutputStream stream = this.updateContentLength ? createTemporaryOutputStream() : response.getOutputStream(); stream.write(bytes); if (this.updateContentLength) { writeToResponse(response, (ByteArrayOutputStream) stream); } } @Override protected void prepareResponse(HttpServletRequest request, HttpServletResponse response) { setResponseContentType(request, response); response.setCharacterEncoding(UTF8.name()); if (this.disableCaching) { response.addHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); response.addHeader(&quot;Cache-Control&quot;, &quot;no-cache, no-store, max-age=0&quot;); response.addDateHeader(&quot;Expires&quot;, 1L); } } public void setDisableCaching(boolean disableCaching) { this.disableCaching = disableCaching; } public void setUpdateContentLength(boolean updateContentLength) { this.updateContentLength = updateContentLength; } protected Object filterModel(Map&lt;String, Object&gt; model) { Map&lt;String, Object&gt; result = new HashMap&lt;String, Object&gt;(model.size()); Set&lt;String&gt; renderedAttributes = !CollectionUtils.isEmpty(this.renderedAttributes) ? this.renderedAttributes : model.keySet(); for (Map.Entry&lt;String, Object&gt; entry : model.entrySet()) { if (!(entry.getValue() instanceof BindingResult) &amp;&amp; renderedAttributes.contains(entry.getKey())) { result.put(entry.getKey(), entry.getValue()); } } if(extractValueFromSingleKeyModel){ if(result.size() == 1){ for(Map.Entry&lt;String, Object&gt; entry : result.entrySet()){ return entry.getValue(); } } } return result; } } 这样一来，就可以完美的支持不同返回类型的异常处理结果了。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"json","slug":"json","permalink":"http://blog.12xiaoshi.com/tags/json/"},{"name":"springmvc","slug":"springmvc","permalink":"http://blog.12xiaoshi.com/tags/springmvc/"}]},{"title":"该死的.htm！记HTTP Status 406的解决方案","slug":"tech/http_status_406","date":"2015-05-25T11:07:01.000Z","updated":"2015-05-25T11:24:06.102Z","comments":true,"path":"2015/05/25/tech/http_status_406/","link":"","permalink":"http://blog.12xiaoshi.com/2015/05/25/tech/http_status_406/","excerpt":"事情是这样，我想与前端异步的交互的时候返回JSON数据，标准的SpringMVC配置，可每次请求都是返回HTTP Status 406 按照各种解决方案，尝试了个遍，包括但不仅限于： 加入jackson的lib，变更各种版本； 替换为GSON的convert方式； 修改produce为application/json； …… 以上方式并没有生效!!!!!!","text":"事情是这样，我想与前端异步的交互的时候返回JSON数据，标准的SpringMVC配置，可每次请求都是返回HTTP Status 406 按照各种解决方案，尝试了个遍，包括但不仅限于： 加入jackson的lib，变更各种版本； 替换为GSON的convert方式； 修改produce为application/json； …… 以上方式并没有生效!!!!!! 最后发现，原来SpringMVC针对请求路径的后缀是*.htm会采用org.springframework.web.accept.ServletPathExtensionContentNegotiationStrategy自动当做text/html来处理，而不会匹配到诸如MappingJacksonHttpMessageConverter，所有406就出现了。 最简单的解决办法，当然是替换掉.htm为其他的后缀了。 当然在不替换*.htm请求路径的前提下，可以去让RequestResponseBodyMethodProcessor注入到ContentNegotiationStrategy对象，来处理@ResponseBody的响应结果,老夫没有试过，各位有尝试麻烦告诉我结果。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"SpringMVC4.1","slug":"SpringMVC4-1","permalink":"http://blog.12xiaoshi.com/tags/SpringMVC4-1/"},{"name":"json","slug":"json","permalink":"http://blog.12xiaoshi.com/tags/json/"}]},{"title":"WAMP局域网内无法通过IP访问的解决方案","slug":"tech/apache2.4_wamp_qa","date":"2015-05-17T14:11:00.000Z","updated":"2015-05-17T14:25:36.415Z","comments":true,"path":"2015/05/17/tech/apache2.4_wamp_qa/","link":"","permalink":"http://blog.12xiaoshi.com/2015/05/17/tech/apache2.4_wamp_qa/","excerpt":"问题在局域网内的windows服务器上配置了WAMP，在浏览器里访问：http://localhost能正常访问，在其他机器上访问：http://192.168.0.128出现403权限不够，192.168.0.128为局域网内服务器的地址。 #解决方案# &lt;Directory &quot;d:/wamp/www&quot;&gt; Require local &lt;/Directory&gt; 修改为： &lt;Directory &quot;d:/wamp/www&quot;&gt; Require all granted &lt;/Directory&gt; 以上解决方案针对2.4的apache版本。","text":"问题在局域网内的windows服务器上配置了WAMP，在浏览器里访问：http://localhost能正常访问，在其他机器上访问：http://192.168.0.128出现403权限不够，192.168.0.128为局域网内服务器的地址。 #解决方案# &lt;Directory &quot;d:/wamp/www&quot;&gt; Require local &lt;/Directory&gt; 修改为： &lt;Directory &quot;d:/wamp/www&quot;&gt; Require all granted &lt;/Directory&gt; 以上解决方案针对2.4的apache版本。 #Apache2.2与Apache2.4中httpd.conf配置文件的异同 #####1、权限设定方式变更 2.2使用Order Deny / Allow的方式，2.4改用Require apache2.2： Order deny,allow Deny from all apache2.4： Require all denied 此处比较常用的有如下几种： Require all denied Require all granted Require host xxx.com Require ip 192.168.1 192.168.2 Require local 注意：若有设定在htaccess文件中的也要修改 #####2、设定日志纪录方式变更 RewriteLogLevel 指令改为 logLevel LOGLEVEL设置第一个值是针对整个Apache的预设等级，后方可以对指定的模块修改此模块的日志记录等级 比如： LogLevel warn rewrite: warn #####3、Namevirtualhost 被移除 #####4、需载入更多的模块开启Gzip在apache2.2中需载入mod_deflate，apache2.4中需载入mod_filter和mod_deflate 开启SSL在apache2.2中需载入mod_ssl，apache2.4中需载入mod_socache_shmcb和mod_ssl #####5、在windows环境建议的设置 EnableSendfile Off EnableMMAP Off 当Log日志出现AcceptEx failed等错误时建议设置 AcceptFilter http none AcceptFilter https none 说明：Win32DisableAcceptEx在apache2.4中被AcceptFilter None取代 #####6、Listen设定的调整 以443为例，不可以只设定Listen 443 会出现以下错误： (OS 10048)一次只能用一个通讯端地址（通讯协定/网路位址/连接) : AH00072: make_sock: could not bind to address [::]:443 (OS 10048)一次只能用一个通讯端地址（通讯协定/网路位址/连接) : AH00072: make_sock: could not bind to address 0.0.0.0:443 AH00451: no listening sockets available, shutting down AH00015: Unable to open logs 因此需指定监听的IP，可设定多个 例如： Listen 192.168.2.1:443 Listen 127.0.0.1:443","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"apache2.4.9","slug":"apache2-4-9","permalink":"http://blog.12xiaoshi.com/tags/apache2-4-9/"},{"name":"wamp","slug":"wamp","permalink":"http://blog.12xiaoshi.com/tags/wamp/"}]},{"title":"Windows下Sonatype Nexus在局域网内无法访问的解决方案","slug":"tech/sonatype_nexus_qa","date":"2015-05-17T14:00:00.000Z","updated":"2015-05-17T14:22:36.176Z","comments":true,"path":"2015/05/17/tech/sonatype_nexus_qa/","link":"","permalink":"http://blog.12xiaoshi.com/2015/05/17/tech/sonatype_nexus_qa/","excerpt":"","text":"问题在局域网内的windows服务器上配置了Sonatype Nexus，在浏览器里访问：http://localhost:8081/nexus能正常访问，在其他机器上访问：http://192.168.0.128:8081/nexus无法访问，192.168.0.128为局域网内服务器的地址。 #解决方案#8081端口默认从局域网其他机器是无法访问的，需要在防火墙中新建入站规则，指定端口为8081即可.","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"maven","slug":"maven","permalink":"http://blog.12xiaoshi.com/tags/maven/"},{"name":"nexus","slug":"nexus","permalink":"http://blog.12xiaoshi.com/tags/nexus/"}]},{"title":"Java解析ISO8601时间标准","slug":"tech/ISO8601_java","date":"2015-05-05T16:35:01.000Z","updated":"2015-09-04T06:24:34.134Z","comments":true,"path":"2015/05/06/tech/ISO8601_java/","link":"","permalink":"http://blog.12xiaoshi.com/2015/05/06/tech/ISO8601_java/","excerpt":"上篇文章讲到了如何获取Apple提供的rss数据，细心的同学一定会发现，Apple返回rss中的时间格式是这样：2015-04-04T23:58:49-07:00 第一眼看到它觉得很难明白，后面老夫特意咨询了下，小白了一回(rss类的时间格式都是这个标准，泪奔)，原来这就是传说中的ISO8601（http://en.wikipedia.org/wiki/ISO_8601），中文名叫做：《数据存储和交换形式·信息交换·日期和时间的表示方法》 所以明白后，这个晦涩的时间格式用中文表示就是： 2015-04-04T23:58:49-07:00 2015年04月04日23时58分49秒（时区UTC-7） 对于Java代码，该怎么解析呢？","text":"上篇文章讲到了如何获取Apple提供的rss数据，细心的同学一定会发现，Apple返回rss中的时间格式是这样：2015-04-04T23:58:49-07:00 第一眼看到它觉得很难明白，后面老夫特意咨询了下，小白了一回(rss类的时间格式都是这个标准，泪奔)，原来这就是传说中的ISO8601（http://en.wikipedia.org/wiki/ISO_8601），中文名叫做：《数据存储和交换形式·信息交换·日期和时间的表示方法》 所以明白后，这个晦涩的时间格式用中文表示就是： 2015-04-04T23:58:49-07:00 2015年04月04日23时58分49秒（时区UTC-7） 对于Java代码，该怎么解析呢？ 复制了一段ISO8601Utils的解析代码，来自著名的Java JSON-processor Jackson： package org.codehaus.jackson.map.util; import java.util.*; /** * Utilities methods for manipulating dates in iso8601 format. This is much much faster and GC friendly than * using SimpleDateFormat so highly suitable if you (un)serialize lots of date objects. */ public class ISO8601Utils { /** * ID to represent the &apos;GMT&apos; string */ private static final String GMT_ID = &quot;GMT&quot;; /** * The GMT timezone */ private static final TimeZone TIMEZONE_GMT = TimeZone.getTimeZone(GMT_ID); /** * Format a date into &apos;yyyy-MM-ddThh:mm:ssZ&apos; (GMT timezone, no milliseconds precision) * * @param date the date to format * @return the date formatted as &apos;yyyy-MM-ddThh:mm:ssZ&apos; */ public static String format(Date date) { return format(date, false, TIMEZONE_GMT); } /** * Format a date into &apos;yyyy-MM-ddThh:mm:ss[.sss]Z&apos; (GMT timezone) * * @param date the date to format * @param millis true to include millis precision otherwise false * @return the date formatted as &apos;yyyy-MM-ddThh:mm:ss[.sss]Z&apos; */ public static String format(Date date, boolean millis) { return format(date, millis, TIMEZONE_GMT); } /** * Format date into yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm] * * @param date the date to format * @param millis true to include millis precision otherwise false * @param tz timezone to use for the formatting (GMT will produce &apos;Z&apos;) * @return the date formatted as yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm] */ public static String format(Date date, boolean millis, TimeZone tz) { Calendar calendar = new GregorianCalendar(tz, Locale.US); calendar.setTime(date); // estimate capacity of buffer as close as we can (yeah, that&apos;s pedantic ;) int capacity = &quot;yyyy-MM-ddThh:mm:ss&quot;.length(); capacity += millis ? &quot;.sss&quot;.length() : 0; capacity += tz.getRawOffset() == 0 ? &quot;Z&quot;.length() : &quot;+hh:mm&quot;.length(); StringBuilder formatted = new StringBuilder(capacity); padInt(formatted, calendar.get(Calendar.YEAR), &quot;yyyy&quot;.length()); formatted.append(&apos;-&apos;); padInt(formatted, calendar.get(Calendar.MONTH) + 1, &quot;MM&quot;.length()); formatted.append(&apos;-&apos;); padInt(formatted, calendar.get(Calendar.DAY_OF_MONTH), &quot;dd&quot;.length()); formatted.append(&apos;T&apos;); padInt(formatted, calendar.get(Calendar.HOUR_OF_DAY), &quot;hh&quot;.length()); formatted.append(&apos;:&apos;); padInt(formatted, calendar.get(Calendar.MINUTE), &quot;mm&quot;.length()); formatted.append(&apos;:&apos;); padInt(formatted, calendar.get(Calendar.SECOND), &quot;ss&quot;.length()); if (millis) { formatted.append(&apos;.&apos;); padInt(formatted, calendar.get(Calendar.MILLISECOND), &quot;sss&quot;.length()); } int offset = tz.getOffset(calendar.getTimeInMillis()); if (offset != 0) { int hours = Math.abs((offset / (60 * 1000)) / 60); int minutes = Math.abs((offset / (60 * 1000)) % 60); formatted.append(offset &lt; 0 ? &apos;-&apos; : &apos;+&apos;); padInt(formatted, hours, &quot;hh&quot;.length()); formatted.append(&apos;:&apos;); padInt(formatted, minutes, &quot;mm&quot;.length()); } else { formatted.append(&apos;Z&apos;); } return formatted.toString(); } /** * Parse a date from ISO-8601 formatted string. It expects a format yyyy-MM-ddThh:mm:ss[.sss][Z|[+-]hh:mm] * * @param date ISO string to parse in the appropriate format. * @return the parsed date * @throws IllegalArgumentException if the date is not in the appropriate format */ public static Date parse(String date) { try { int offset = 0; // extract year int year = parseInt(date, offset, offset += 4); checkOffset(date, offset, &apos;-&apos;); // extract month int month = parseInt(date, offset += 1, offset += 2); checkOffset(date, offset, &apos;-&apos;); // extract day int day = parseInt(date, offset += 1, offset += 2); checkOffset(date, offset, &apos;T&apos;); // extract hours, minutes, seconds and milliseconds int hour = parseInt(date, offset += 1, offset += 2); checkOffset(date, offset, &apos;:&apos;); int minutes = parseInt(date, offset += 1, offset += 2); checkOffset(date, offset, &apos;:&apos;); int seconds = parseInt(date, offset += 1, offset += 2); // milliseconds can be optional in the format int milliseconds = 0; // always use 0 otherwise returned date will include millis of current time if (date.charAt(offset) == &apos;.&apos;) { checkOffset(date, offset, &apos;.&apos;); milliseconds = parseInt(date, offset += 1, offset += 3); } // extract timezone String timezoneId; char timezoneIndicator = date.charAt(offset); if (timezoneIndicator == &apos;+&apos; || timezoneIndicator == &apos;-&apos;) { timezoneId = GMT_ID + date.substring(offset); } else if (timezoneIndicator == &apos;Z&apos;) { timezoneId = GMT_ID; } else { throw new IndexOutOfBoundsException(&quot;Invalid time zone indicator &quot; + timezoneIndicator); } TimeZone timezone = TimeZone.getTimeZone(timezoneId); if (!timezone.getID().equals(timezoneId)) { throw new IndexOutOfBoundsException(); } Calendar calendar = new GregorianCalendar(timezone); calendar.setLenient(false); calendar.set(Calendar.YEAR, year); calendar.set(Calendar.MONTH, month - 1); calendar.set(Calendar.DAY_OF_MONTH, day); calendar.set(Calendar.HOUR_OF_DAY, hour); calendar.set(Calendar.MINUTE, minutes); calendar.set(Calendar.SECOND, seconds); calendar.set(Calendar.MILLISECOND, milliseconds); return calendar.getTime(); } catch (IndexOutOfBoundsException e) { throw new IllegalArgumentException(&quot;Failed to parse date &quot; + date, e); } catch (NumberFormatException e) { throw new IllegalArgumentException(&quot;Failed to parse date &quot; + date, e); } catch (IllegalArgumentException e) { throw new IllegalArgumentException(&quot;Failed to parse date &quot; + date, e); } } /** * Check if the expected character exist at the given offset of the * * @param value the string to check at the specified offset * @param offset the offset to look for the expected character * @param expected the expected character * @throws IndexOutOfBoundsException if the expected character is not found */ private static void checkOffset(String value, int offset, char expected) throws IndexOutOfBoundsException { char found = value.charAt(offset); if (found != expected) { throw new IndexOutOfBoundsException(&quot;Expected &apos;&quot; + expected + &quot;&apos; character but found &apos;&quot; + found + &quot;&apos;&quot;); } } /** * Parse an integer located between 2 given offsets in a string * * @param value the string to parse * @param beginIndex the start index for the integer in the string * @param endIndex the end index for the integer in the string * @return the int * @throws NumberFormatException if the value is not a number */ private static int parseInt(String value, int beginIndex, int endIndex) throws NumberFormatException { if (beginIndex &lt; 0 || endIndex &gt; value.length() || beginIndex &gt; endIndex) { throw new NumberFormatException(value); } // use same logic as in Integer.parseInt() but less generic we&apos;re not supporting negative values int i = beginIndex; int result = 0; int digit; if (i &lt; endIndex) { digit = Character.digit(value.charAt(i++), 10); if (digit &lt; 0) { throw new NumberFormatException(&quot;Invalid number: &quot; + value); } result = -digit; } while (i &lt; endIndex) { digit = Character.digit(value.charAt(i++), 10); if (digit &lt; 0) { throw new NumberFormatException(&quot;Invalid number: &quot; + value); } result *= 10; result -= digit; } return -result; } /** * Zero pad a number to a specified length * * @param buffer buffer to use for padding * @param value the integer value to pad if necessary. * @param length the length of the string we should zero pad */ private static void padInt(StringBuilder buffer, int value, int length) { String strValue = Integer.toString(value); for (int i = length - strValue.length(); i &gt; 0; i--) { buffer.append(&apos;0&apos;); } buffer.append(strValue); } }","categories":[],"tags":[{"name":"ISO8601","slug":"ISO8601","permalink":"http://blog.12xiaoshi.com/tags/ISO8601/"},{"name":"rss时间","slug":"rss时间","permalink":"http://blog.12xiaoshi.com/tags/rss时间/"},{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"}]},{"title":"AppStore应用排行榜、应用获取接口","slug":"tech/appstore_affiliates_resource","date":"2015-05-04T02:35:01.000Z","updated":"2015-09-04T06:24:12.351Z","comments":true,"path":"2015/05/04/tech/appstore_affiliates_resource/","link":"","permalink":"http://blog.12xiaoshi.com/2015/05/04/tech/appstore_affiliates_resource/","excerpt":"老夫研究了一个下午apple的rss和search服务接口，总算知道怎么抓取应用排行榜和查找应用的接口参数了。现总结下，给各位一个参考。 ####抓取应用排行榜（上限200） http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/ws /RSS ------&gt;查应用排行榜，就是Feed形式了，当然可以查询其他 /topfreeapplications ------&gt;免费排行榜，收费、畅销、最新等，见下文 /limit=5 ------&gt;返回结果数量，上限200 /genre=6002 ------&gt;所在分类，对应code查询地址： /json ------&gt;xml or json ?cc=cn ------&gt;cc这个参数纯属误撞到的，表示所在国家或地区，参考:http://en.wikipedia.org/wiki/%20ISO_3166-1_alpha-2 &amp;key=value ------&gt;其他参数的键值对，自己摸索 比如，查询当前排名前10，地区为中国的iOS应用，链接就是： http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/ws/RSS/topfreeapplications/limit=5/json?cc=cn","text":"老夫研究了一个下午apple的rss和search服务接口，总算知道怎么抓取应用排行榜和查找应用的接口参数了。现总结下，给各位一个参考。 ####抓取应用排行榜（上限200） http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/ws /RSS ------&gt;查应用排行榜，就是Feed形式了，当然可以查询其他 /topfreeapplications ------&gt;免费排行榜，收费、畅销、最新等，见下文 /limit=5 ------&gt;返回结果数量，上限200 /genre=6002 ------&gt;所在分类，对应code查询地址： /json ------&gt;xml or json ?cc=cn ------&gt;cc这个参数纯属误撞到的，表示所在国家或地区，参考:http://en.wikipedia.org/wiki/%20ISO_3166-1_alpha-2 &amp;key=value ------&gt;其他参数的键值对，自己摸索 比如，查询当前排名前10，地区为中国的iOS应用，链接就是： http://ax.itunes.apple.com/WebObjects/MZStoreServices.woa/ws/RSS/topfreeapplications/limit=5/json?cc=cn ####查询单个应用明细（不含排行榜） https://itunes.apple.com/lookup ?id=510909506 —–&gt;应用Id 比如： https://itunes.apple.com/lookup?id=444722625 以上所有信息，都可以在Apple的网站上查询到，如下： http://www.apple.com/itunes/affiliates/resources/documentation/itunes-store-web-service-search-api.html https://rss.itunes.apple.com/us ####痛苦要是appstore可以分页查询，没有应用排行榜200上限限制，就可以时刻监控我的app的排名了。要是国内服务器可以顺利访问到服务，就不会这么痛苦的爬数据了。","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"appstore","slug":"appstore","permalink":"http://blog.12xiaoshi.com/tags/appstore/"},{"name":"itunes","slug":"itunes","permalink":"http://blog.12xiaoshi.com/tags/itunes/"}]},{"title":"我常用的chrome扩展程序","slug":"tech/chrome_plugs","date":"2015-04-26T05:50:00.000Z","updated":"2015-04-26T06:00:26.939Z","comments":true,"path":"2015/04/26/tech/chrome_plugs/","link":"","permalink":"http://blog.12xiaoshi.com/2015/04/26/tech/chrome_plugs/","excerpt":"","text":"No.1 Adblock Plus免费的广告拦截器，可阻止所有烦人的广告及恶意软件和跟踪。 地址：https://chrome.google.com/webstore/detail/cfhdojbkjhnklbpkdaibdccddilifddb No.2 JSONView格式化Json，对于http请求返回为json的，一目了然。 地址：https://chrome.google.com/webstore/detail/chklaanhfefbnpoihckbnefhakgolnmc No.3 PrettyPrintJavascript/css 高亮格式化显示利器。 地址：https://chrome.google.com/webstore/detail/nipdlgebaanapcphbcidpmmmkcecpkhg No.4 网页截图:注释&amp;批注捕获整个页面或任何部分，矩形，圆形，箭头，线条和文字，模糊敏感信息，一键上传分享注释。支持PNG和链接。 地址：https://chrome.google.com/webstore/detail/alelhddbbhepgpmgidjdcjakblofbmce No.5 SnappySnippet非常方便的到处选中的HTML元素以及关联的css，支持一键发送对应内容到CodePen, jsFiddle ， JS Bin 。类似扩展：CSS+HTML,相比SnappySnippet的优点是保持原有元素的选择器不变。 地址：https://chrome.google.com/webstore/detail/blfngdefapoapkcdibbdkigpeaffgcil No.6 User-Agent Switcher该扩展可以轻松的切换User-Agent，可快速的在浏览器中模拟不同终端的效果。 地址：https://chrome.google.com/webstore/detail/ffhkkpnppgnfaobgihpdblnhmmbodake","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"chrome","slug":"chrome","permalink":"http://blog.12xiaoshi.com/tags/chrome/"},{"name":"扩展程序","slug":"扩展程序","permalink":"http://blog.12xiaoshi.com/tags/扩展程序/"}]},{"title":"Maven构建应用的命令","slug":"tech/maven_project","date":"2015-04-19T15:49:01.000Z","updated":"2017-07-12T07:59:55.468Z","comments":true,"path":"2015/04/19/tech/maven_project/","link":"","permalink":"http://blog.12xiaoshi.com/2015/04/19/tech/maven_project/","excerpt":"","text":"mvn archetype:generate -DgroupId=com.kalman03 -DartifactId=my-webapp -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=false 构建一个web应用，不会还记不住吧？！！！","categories":[],"tags":[{"name":"技术","slug":"技术","permalink":"http://blog.12xiaoshi.com/tags/技术/"},{"name":"maven","slug":"maven","permalink":"http://blog.12xiaoshi.com/tags/maven/"}]},{"title":"纠结与向往","slug":"life/new_start","date":"2015-04-19T08:31:01.000Z","updated":"2015-04-19T08:31:58.667Z","comments":true,"path":"2015/04/19/life/new_start/","link":"","permalink":"http://blog.12xiaoshi.com/2015/04/19/life/new_start/","excerpt":"","text":"这个决定其实在我心里面很久了，只是一直在寻找一个机会，今天，我签署了协议，意味着我即将离职。 一直问自己，到底需要怎样的生活，在这么个互联网公司的日子不算太好也不算太坏，但内心深处的向往还是无比的强烈。也许，我比较任性，但人若不逼一下，又怎么知道最后怎样呢？！ 不管结局如何，如老婆所说 “反正都这样了，置之死地而后生，展望未来，一切都会好的！” 那就以崭新的姿态迎接新的生活吧，加油，还是那句话：男人，就应该对自己狠一点！","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.12xiaoshi.com/tags/生活/"}]},{"title":"博客迁移与后续计划","slug":"life/bog_redirect_ to_github","date":"2015-04-08T16:00:01.000Z","updated":"2015-04-11T01:54:31.365Z","comments":true,"path":"2015/04/09/life/bog_redirect_ to_github/","link":"","permalink":"http://blog.12xiaoshi.com/2015/04/09/life/bog_redirect_ to_github/","excerpt":"","text":"作为一个Java开发，同时也是一个抱有梦想的互联网技术人，对各位可以玩转Github Pages真是羡慕也是惭愧，惭愧自己一直不会弄这玩意。 这个清明节，总算有时间了。于是乎，折腾了一个下午，搞了一个基于Hexo的站点，托管于Github，采用yilia主题。话说，这个主题自我感觉很漂亮，感谢作者！ 很久没有写博客，之前的博客位于http://blog.12xiaoshi.com，wordpress搭建，可以用年久失修来形容。后面，经过慎重的决定，域名将指向Github,与大家一起分享我在自我陶醉的产品项目中，以及生活中点滴。","categories":[],"tags":[{"name":"生活","slug":"生活","permalink":"http://blog.12xiaoshi.com/tags/生活/"},{"name":"博客迁移","slug":"博客迁移","permalink":"http://blog.12xiaoshi.com/tags/博客迁移/"}]}]}